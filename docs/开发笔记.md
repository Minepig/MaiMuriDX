# MaiMuriDX 开发笔记 (By Minepig)  

由于我本人对于这个程序的代码结构与风格并不是很自信，因此有了本文档，用于记录程序逻辑的梳理、各种无理配置的详细定义、以及我在编写该检测器时的一些迷惑操作等。  

本文默认读者对于 Maimai 的游玩、判定、以及各种相关术语有最基本的了解，若不了解这些内容，可以先阅读最后的附录：Maimai 判定全解。不过如果已经了解了这些内容，我也建议阅读一遍附录，以将各类细节对齐到目前的最新框体上。
  
## MaiMuriDX 对于无理的定义  
  
无理配置在 Maimai 自制圈内没有一个特别明确的定义，通常指正攻无法AP的配置。在编写 MaiMuriDX 时，考虑到无理配置本身不是绝对不可以出现的，但那些**谱师不知道其存在的无理**是不应当出现的。因此本着宁错杀毋放过的思想，MaiMuriDX 所认定的无理，范围更宽松化（而且这样代码写起来更简单，乐）。具体定义如下：

> 无理配置，指严格按照正规手法游玩无法达成 **DX 分理论值**的配置。

与通常的认知相比最明显的差异是要求由 AP 提升至 DX 分理论，看似区别不大，但实际上“正规手法”才是最主要的差异。MaiMuriDX 对于“正规手法”的要求极为严格，因而会有一些通常不被认为是无理的配置被 MaiMuriDX 报告成无理。

MaiMuriDX 将无理配置分为五类：

- 多押无理：同一时刻需要三只及以上的手处理配置；
- 内屏无理：全部 Note 内屏正攻时必然会蹭的 Slide；
- 外键无理：Slide 启动后一定时间内出现同头 Tap 或 Hold；
- 撞尾无理：Slide 划动经过 A 区时该区出现 Tap 或 Hold；
- 叠键无理：同一时刻同一区域出现两个 Note。

接下来详细介绍每一个概念在 MaiMuriDX 中的具体规定，这些内容部分总结自 luvlily 于 2023 年 7 月发布的无理详解专栏（cv24836948）以及 VirenceChannel 于 2024 年 7 月发布的舞萌网课（BV1HT42167Qb 和 BV1b2421Z752）。除总结与修正外，还包含有较多的个人理解，可能与大众的认知有所出入。

### 正规手法

正攻，或称正规手法，是无理判定的核心。MaiMuriDX 对每一种 Note 预设的正规手法是：Tap/Hold/Touch/TouchHold 按压内屏的对应判定区一段时间；Slide 沿 Slide Track 的中心线匀速划动，即手始终按着引导星星。需要注意的是，由于 **Slide 的正规手法是划动，而不是依次点按判定区**，正攻处理 Slide 时可能会不可避免地接触到附近的其他判定区，MaiMuriDX 认为**这种意外的接触也属于正规手法的一部分**。

如下图所示，8-5 Slide 的轨迹距离 B8 判定区边界仅 29 px，约合 1.45 cm，作为对比，Slide Track 的箭头宽 72 px，约合 3.6 cm，因此 8-5 的 Slide Track 实际上确实接触到了 B8 区（虽然只有约 7 px 即 0.35 cm）。而实际游玩时手具有一定的接触面积，考虑到 Maimai 使用电容触摸原理，且通常为了防止吃音灵敏度会设的较高，故 MaiMuriDX 的默认参数中设定，手的接触区域是一个半径为 40 px 的圆形，即直径 4 cm，大约是戴着手套时 2~3 根手指并起来时的宽度。

![8-5_on_B8.png](https://raw.githubusercontent.com/Minepig/MaiMuriDX/master/docs/images/8-5_on_B8.png)

因此在这个预设条件下，`{4}8-5[8:1],2-7[8:1],7,`（如下图）在 BPM 较低时可以构成内屏无理，因为 8-5 会在 A2 击打星星头之后接触到 B8 导致 2-7 的 B1 区被跳过，然后 A7 击打 Tap 时蹭掉 2-7。尽管 B8 并不在 8-5 的判定队列中，这个配置也因此普遍被认为不是无理，但 MaiMuriDX 依旧会将其报告成无理。（所谓“宁错杀毋放过”）

![8-5_crash_2-7.png](https://raw.githubusercontent.com/Minepig/MaiMuriDX/master/docs/images/8-5_crash_2-7.png)


当然，MaiMuriDX 中手的半径是可调的参数，若将其调至 29 px 以下，则上述配置就不会被报告，可以根据实际情况进行自定义。

此外，依然是考虑到 Maimai 内屏的触屏原理，也是便于后续检测多押无理，MaiMuriDX 为所有的按压、划动操作添加了抬手的延迟，该参数默认设置为 1.333 帧，即约 22.22 ms。也即是说所有的 Tap/Touch 在 MaiMuriDX 的正规手法中被视为持续 22.22 ms 的超短 Hold，而原本的所有 Hold/TouchHold 会在原来的持续时间基础上额外增加 22.22 ms 的持续。所有的 Slide 若不处于一笔画配置中（即结束的位置没有同时启动的其他 Slide），也会在终点额外停留 22.22 ms 再松开。

默认参数 22.22 ms 的选取是基于 Maimai 官谱中速度最快的扫键（白 Sun Dance 的 102 BPM 96 分圈）时间间隔为 24.51 ms，需要保证该扫键不会被识别为双押。

添加抬手延迟的另一个考量是我本人对于使用间隔128分、384分等的伪双押来逃避多押无理的行为不太看好，抬手延迟的存在会把伪双押也识别成双押，从而**防止用伪双逃多押的行为**。如果确实需要伪双逃多押的话请谱师自行忽略该条多押无理报告。

综上所述，MaiMuriDX 中所规定的正规手法如下（默认参数的情况）：

- Tap/Touch：按压对应内屏判定区 22.22 ms；
- TouchGroup：选取能够覆盖所有 Touch 的最小圆作为手掌的按压范围，按压 22.22 ms，若该圆半径超过某定值则视为双手配置（但依然使用单个圆进行按压判定处理）；
- Hold/TouchHold：按压对应内屏判定区 <Hold 持续时间> + 22.22 ms；
- Slide：在 Slide Star 到达时按压对应判定区 22.22 ms 后松开，等待一拍后开始沿 Slide Track 的中心线匀速划动，在终点额外停留 22.22 ms（若终点处同时有其他 Slide 启动则不停留），且划动过程中意外接触到附近的判定区也被归入正规手法中；
- Wifi：在 Slide Star 到达时按压对应判定区 22.22 ms 后松开，等待一拍后双手以较大的手掌半径（默认为 100 px，即 5 cm），从起点匀速划动至三个终点 A 区所夹的两个 D 区，然后额外停留 22.22 ms（以 1w5 为例，正规手法定为双手分别从 A1 划至 D5 和 D6，且接触半径比普通 Slide 更大）。

以上手法中若无特殊说明，手掌半径默认值采用 40 px，即 2 cm，略宽于 Slide Track 的箭头。


### 多押无理

多押无理，顾名思义，因为 Maimai 玩家都只有两只手，所以**任何同时需要三只手及以上的配置都属于无理配置**。多押无理的基本概念非常容易理解，但是自从 DX 代引入 Touch 以后，由于有 TouchGroup 半数以上判定的容错机制，多押的界限就变得模糊。我个人的推测是官谱对于 Touch 参与形成多押的容忍度很高，但不是完全没有限制，故 MaiMuriDX 对于 Touch 相关的配置也添加了多押检测规则，该规则似乎比官谱更为严苛，因为确实有很多官谱 Touch 配置也被识别成了多押。

> 很喜欢 Minepig 的一句话：无理检测结果仅供谱师参考，我负责尽可能仔细地检查，需不需要改自有谱师定夺。

MaiMuriDX 采用的处理方法是，**允许总半径不超过一定值的 TouchGroup 作为单手配置处理**。默认参数中该阈值为 180 px，即尝试用直径不超过 360 px（18 cm）的圆覆盖 TouchGroup，若可以覆盖（以 Touch 中心的圆点为准），则该组 TouchGroup 视为单手配置。因此以下配置都会被 MaiMuriDX 认为是正常双押（图中红色圆的半径为 180 px）：

![touchgroup1.png](https://raw.githubusercontent.com/Minepig/MaiMuriDX/master/docs/images/touchgroup1.png) ![touchgroup2.png](https://raw.githubusercontent.com/Minepig/MaiMuriDX/master/docs/images/touchgroup2.png) ![touchgroup3.png](https://raw.githubusercontent.com/Minepig/MaiMuriDX/master/docs/images/touchgroup3.png)

而下图中的配置会被 MaiMuriDX 视为三押无理，这是因为需要半径约 240 px 的圆（图中红色实线）才可覆盖全部 9 个 Touch，而半径为 180 px 的圆（图中红色虚线）不足以覆盖，因此该 TouchGroup 被视为双手配置，从而与 Slide 构成了三押：

![touchgroup4.png](https://raw.githubusercontent.com/Minepig/MaiMuriDX/master/docs/images/touchgroup4.png)

需要注意的是，**只有 TouchGroup 可以被合并为单手配置，两个不组成 TouchGroup 的 Touch 是一定会被 MaiMuriDX 认为是双押的**，例如室内系 1:56 处 `{8}2h[4:1],E2/E3,` 会被 MaiMuriDX 认定为三押，尽管 E2 与 E3 之间的距离是小于 360 px 的。

这是由于 TouchGroup 具有半数以上完成的保护机制，对于 `E2/E3/B2` 这样的 TouchGroup，实际上只需要按压 E2 和 B2 已经足以完成，这相对于 `E2/E3` 这样的 Touch 双押，对于手张大的尺寸要求更宽松。因此，MaiMuriDX 不会把不属于同一个 TouchGroup 的 Touch 合并为单手配置。

另外，TouchHold 是完全不参与形成 TouchGroup 的，故官谱紫 DX 圣诞 0:04 处 TouchHold 尾判与大范围 TouchGroup 同时，会被 MaiMuriDX 判为三押（TouchHold 单押 + 大 TouchGroup 双押）

![インドア系ならトラックメイカー.png](https://raw.githubusercontent.com/Minepig/MaiMuriDX/master/docs/images/インドア系ならトラックメイカー.png) ![ジングルベル [DX].png](https://raw.githubusercontent.com/Minepig/MaiMuriDX/master/docs/images/%E3%82%B7%E3%82%99%E3%83%B3%E3%82%AF%E3%82%99%E3%83%AB%E3%83%98%E3%82%99%E3%83%AB%20[DX].png)

再如官谱红 DX 牛奶中包含了大量在 MaiMuriDX 中会被判为三押的 Touch 配置：

![Oshama Scramble! [DX] Expert (1).png](https://raw.githubusercontent.com/Minepig/MaiMuriDX/master/docs/images/Oshama%20Scramble!%20[DX]%20Expert%20(1).png) ![Oshama Scramble! [DX] Expert (2).png](https://raw.githubusercontent.com/Minepig/MaiMuriDX/master/docs/images/Oshama%20Scramble!%20[DX]%20Expert%20(2).png)
![Oshama Scramble! [DX] Expert (3).png](https://raw.githubusercontent.com/Minepig/MaiMuriDX/master/docs/images/Oshama%20Scramble!%20[DX]%20Expert%20(3).png) ![Oshama Scramble! [DX] Expert (4).png](https://raw.githubusercontent.com/Minepig/MaiMuriDX/master/docs/images/Oshama%20Scramble!%20[DX]%20Expert%20(4).png)

上述四张图中，第一、三张图的 TouchGroup 与 TouchHold 组 Each 的配置实际上机打起来会有一点点别扭（TouchHold 开头一小段时间容易放手）。第二张图有点像传统意义上的慢速 Slide 划动时出现双押配置导致的三押（注意 E 区与 C 区不相邻，无法组成 TouchGroup）。第四张图虽说大家都知道怎么打，大多数人也不认为这是一个三押，不过为了检测的一致性，还是把这种无法组成 TouchGroup 的情况归入三押的范畴（Festival 及以后的版本这种配置应该已经比较少见了）。

与 Touch 多押有关的另一个配置是 Slide 撞 Touch 的配置，MaiMuriDX 会沿着 Slide Track 逐个判定区进行检查，**如果引导星星的中心点进入某个判定区时该区恰好有 Touch 处于 Critical 区间，则该 Touch 视为不需要处理**。典型案例如官谱 SUPER AMBULANCE 1:30 处的 Tap-Touch-Slide 三押，由于 Touch 可以被 Slide 蹭黄因而不算作三押：

![SUPERAMBULANCE.png](https://raw.githubusercontent.com/Minepig/MaiMuriDX/master/docs/images/SUPERAMBULANCE.png)

与内无检测不同，在检测多押时，MaiMuriDX 对于 Slide Track 经过哪些判定区的判定是较为严格的，对于不在 Slide 判定队列中的判定区，要求 Slide Track 中心线经过了某个判定区才会把这个判定区的 Touch 纳入考虑。例如上文提到 8-5 在手的半径 > 29 px 时会蹭到 B8 区，但即便如此，此时 B8 区的 Touch 依然不会视为位于 8-5 之上，因而需要分出一只手单独处理。因此，会出现一个比较自相矛盾的检测结果，例如下图所示的 `{8}8-5[8:1],2p5[8:1],,,B5/E7,` 既会被报告为内屏无理（8-5 蹭到 B8 带走了 2p5），也会被报告为多押无理（2p5、B6、E7 三押），尽管这意味着需要假设 8-5 可以蹭到 B8 而 2p5 却不能蹭 B6 的双标行为，但是正所谓“宁错杀毋放过”，这确实是 Intended Behavior：

![contradiction.png](https://raw.githubusercontent.com/Minepig/MaiMuriDX/master/docs/images/contradiction.png)

对于 TouchGroup 而言，要求其中所有的 Touch 都被 Slide 撞到，才会认为整个 TouchGroup 都无需处理，任意一个 Touch 没有被撞到的情况下，都会认为需要处理完整大小的 TouchGroup。例如下面左图的配置中如果星星速度合适，那么所有的 Touch 在 MaiMuriDX 的设定中都可以被 Wifi 蹭掉因而不是无理，而右图中额外多出来的 E3、E4、E7、E8 被认为在 Wifi 之外，因而构成了四押（整个 TouchGroup 双押 + Wifi 双押）。当然，无论是左图还是右图的配置都太过于抽象不建议写。

![wifi_touch_1.png](https://raw.githubusercontent.com/Minepig/MaiMuriDX/master/docs/images/wifi_touch_1.png) ![wifi_touch_2.png](https://raw.githubusercontent.com/Minepig/MaiMuriDX/master/docs/images/wifi_touch_2.png)

实际上上面左图中包含的 18 个 Touch 再加上 A1，就是 Wifi 允许蹭掉的所有 19 个 Touch 了，剩余 14 个 Touch 被 MaiMuriDX 认为是在 Wifi 之外，如果写了就会被报告多押。

再比如官谱中常出现的双 Slide 夹 C 区 Touch 的配置，由于 Slide 并不直接经过 C 区，也会被 MaiMuriDX 判定为多押，例如 TEmPTaTiON 2:11 处的 `{4}3-8[8:1]/7-4[8:1],C1f,` 和魔法少女与巧克力 0:44 处的 `{4}3-8[8:1]/7-4[8:1],{32},E8/E4,C,` 在 MaiMuriDX 中都会被认为是多押：

![TEmPTaTiON.png](https://raw.githubusercontent.com/Minepig/MaiMuriDX/master/docs/images/TEmPTaTiON.png) ![魔法少女とチョコレゐト.png](https://raw.githubusercontent.com/Minepig/MaiMuriDX/master/docs/images/魔法少女とチョコレゐト.png)

> Tips：其实由于这种配置在官谱里太多了，因此我曾一度想为其开一条绿色通道写个特判，但后来因为实现起来太麻烦了就没写，咕咕。

再例如白系 2:00 处 TouchGroup 与双 Slide 组成拍划配置，由于 D1 区 Touch 不在 Slide 路径上，故 MaiMuriDX 会把此配置报告为三押：

![系ぎて.png](https://raw.githubusercontent.com/Minepig/MaiMuriDX/master/docs/images/系ぎて.png)

以上为 MaiMuriDX 为 Touch 配置指定的多押判定法则。由于 Touch 配置从程序的角度看大多较为复杂，故 MaiMuriDX 对于 Touch 做了较大的限制，因此也容易产生假阳性，或者我们也可以把与 Touch 有关的多押无理称为**软多押**，因为 Touch 判定很松。在处理完 Touch 带来的问题以后，多押无理就很容易理解和检测了。

关于多押还有一个注意点，轨迹重合的 Slide 被认为是单押，典型例子如相信彩虹的重叠 Slide，MaiMuriDX 也对这类情况做了适配，会把同一时刻相距较近且移动方向相近的 Slide 触点合并（默认参数下是距离 < 20 px，移动方向相差 < 3°），但依然会出现少量的假阳性。此外，这种适配也意味着如白 In Chaos 0:31 处的 `{8}4v1[8:1]/6v1[8:1],1,4/6,2,` 这种配置不会被算作三押：

![in chaos Remaster.png](https://raw.githubusercontent.com/Minepig/MaiMuriDX/master/docs/images/in%20chaos%20Remaster.png)

因为 4v1 和 6v1 的后半部分重合了，就视作单押，和 7 号键 Tap 只构成双押。


### 内屏无理

内屏无理，简称内无，原指全内屏正攻时无法达成理论值的配置。在旧框时代，内屏无理的产生原因有两种：其一是由于谱面设计失误，导致内屏正攻时 Slide 会被过早蹭掉；其二是正在按压 Hold 时，同键位上出现了 Tap，形成一种必须内屏与外键联合使用才能处理的配置。但第二类情况一般不可能发现不了，出现了往往是谱师有意而为之。因此当提及“内屏无理”时，通常专指上述第一类情况。

在 Festival 代引入 A 区 Touch 后，由于 Maimai 的判定机制要求同一个判定区在一帧内最多只能判定一个 Slide 以外的 Note，因此在 A 区 Touch 与 Tap 同时出现的情况下，纯内屏游玩必须要连续点击 A 区两次才能处理，或者直接内外联合处理。因为这种配置与上述第二类内无有所相似，于是这种配置也被纳入了“内屏无理”的范畴。

考虑到上述两类内屏无理拥有完全不相关的成因，而且玩家谈论“内屏无理”时大多数情况都是专指上述第一类内无，故 MaiMuriDX 将第二类内无独立拆分成了“叠键无理”，而“内屏无理”则专指第一类内无，即 Slide 被过早蹭掉的情况。

由于 Slide 与 Touch 只能内屏击打，故即使全外键正攻，在谱面设计失误时也可能出现 Slide 被过早蹭掉的无理配置，严格意义上来说这种无论内屏正攻还是外键正攻均不能达成最高评价的配置应该被称为“绝对无理”而不是“内屏无理”，但是由于其成因与一般的内无一致，故 MaiMuriDX 统一以“内屏无理”代指任何 Slide 被过早蹭掉的配置。

内屏无理的核心在于理解 Slide 的判定机制，インクInku墨 于 2021 年发布过一个关于 Slide 跳区判定的详解视频（BV1Tq4y1f73d），MajdataView&Edit 的贡献者之一 墨滢-moying 也曾于 2022 年在其 Maimai 判定全解专栏（cv18133076）中详细介绍了 Slide 的判定，在此对 Slide 判定规则作必要的介绍。（详细内容参见附录：Maimai 判定全解）

一条 Slide 会经过若干个内屏上的判定区，这些判定区将 Slide 分割成了一段一段的“判定段”，每个判定段都对应于内屏上 1~2 个判定区。**想要完成一条 Slide，原则上应该依次触碰每一个判定段的至少一个判定区**。注意 **D 区和 E 区是完全不参与 Slide 判定的**，因此 Slide 分割判定段时也会对 D 区和 E 区视而不见（例外是 Wifi）。

可能是出于一些容错机制，Slide 会在每一帧中**依次检查当前判定队列中的前两个判定段**，除了检查第一个判定段是否在本帧内从 ON 状态变为 OFF 状态以外，**如果第二个判定段已经 ON，则会忽略第一个判定段的状态直接将其移出队列**，使得第二个判定段成为第一个判定段，并等待其松开，这被称为“跳区”。跳区规则的存在使得全内屏正攻时，Slide 更容易被提前蹭掉。

在两种情况下跳区会被禁用：

1. 判定队列总长度 ≤ 3 的标准 Slide 或连锁 Slide，其倒数第二个判定段不可以跳过，如 1<8 不可跳 A1、1>3 不可跳 A2、1-7 不可跳 A8/B8；1>2>3 同 1>3，也不可跳 A2；
2. 单独一条标准的转折 Slide（即大 V 形 Slide）中长度为 3 的部分，第二个判定段不可跳过，例如 1V35 的第二段 A2/B2、第四段 A4/B4 均不可跳过，1V73 的第二段 A8/B8 不可跳过。

在跳区被禁用的情况下，Slide 不会在当前判定队列中的第一个判定区还未 ON 的情况下，检查第二个判定区，但如果第一个判定区已经处于 ON 状态，那么按下第二个判定区依然可以触发跳区，无需等待第一个判定区松开。

对于 Festival 代加入的连锁 Slide，其判定队列为各部分拼合的结果，同样适用于上述判定与跳区规则。特别的，对于 1-3-5，尽管其形状和 1V35 相同，但由于它不是转折 Slide，故不适用于上述第二条规则，由于其判定队列总长度为 5，不存在不可跳过的判定段。如果转折 Slide 参与形成连锁 Slide，也会失去上述第二条的特权，例如 1-3V57 和 1-3-5-7 一样，每一个判定段都可以跳过，不会因为 3V57 的存在导致 A4/B4 和 A6/B6 不允许跳区。

在理解 Slide 的判定与跳区机制后，内屏无理的原理便呼之欲出了。以幽灵东京 1:04 处为例，相关谱面为 `{4}7x-3[8:1],1xs5[4:1],5x,`：

![幽霊東京.png](https://raw.githubusercontent.com/Minepig/MaiMuriDX/master/docs/images/幽霊東京.png)

由于 MaiMuriDX 给 Slide 规定的正规手法在拍击 Slide Star 后会松手（这是更容易产生内无的手法），那么在 7-3 启动时拍击 A1 再松开，1s5 的 A1 区解决，然后 7-3 依次划过 B7，C，B3，1s5 只剩 B4 和 A5 两个区，然后内屏拍击 A5 的 Tap，此时 1s5 刚刚启动就已经完成，直接判绿了。MaiMuriDX 给出的检测结果如下，与上述分析符合：

```
[01:04F36.00] 内屏无理："1xs5[4:1]"(L35,C14) 被提前蹭掉，相关判定区如下
    A1: "1x_"(L35,C7)@01:04F07.00 (H+3.76, S-480.11, J-910.31, E-963.98)
    B8: Skipped
    B7: "7x-3[8:1]"(L34,C30)@01:04F09.00 (H+37.10, S-446.77, J-876.97, E-930.65)
    C: "7x-3[8:1]"(L34,C30)@01:04F12.00 (H+87.10, S-396.77, J-826.97, E-880.65)
    B3: "7x-3[8:1]"(L34,C30)@01:04F15.67 (H+148.21, S-335.66, J-765.86, E-819.53)
    B4: Skipped
    A5: "5x"(L35,C18)@01:04F36.00 (H+487.10, S+3.23, J-426.97, E-480.65)
```

再如星果君 1:00 处的 `{4}2-6[8:1],4^7[4:1],7^2[4:1],` 以及后续 1:11 处相同配置的 180°旋转：

![星めぐり、果ての君へ.png](https://raw.githubusercontent.com/Minepig/MaiMuriDX/master/docs/images/星めぐり、果ての君へ.png)

```
[01:01F12.00] 内屏无理："4^7[4:1]"(L44,C28) 被提前蹭掉，相关判定区如下
    A4: "4_"(L44,C21)@01:00F51.67 (H+5.40, S-337.46, J-645.96, E-680.32)
    A5: Skipped
    A6: "2-6[8:1]"(L44,C18)@01:00F59.67 (H+138.73, S-204.13, J-512.62, E-546.98)
    A7: "7_"(L44,C31)@01:01F12.00 (H+344.29, S+1.43, J-307.07, E-341.43)
```

上述两个配置形成的内屏无理有一个共有特点：第二个判定区被跳过。在这种类型的内屏无理中， Slide 若要被蹭掉硬性要求 Slide Star 拍击完以后松手，否则第一个判定区不完成，触碰第三个判定区无法跳区，也就不会蹭。在实际配置中如果拍击 Slide Star 的手可以不松手，那么就可以避免蹭掉 Slide，因此这种内无称为**软内无**。

需要注意的是**第二个判定区被跳过是上述软内无的必要非充分条件**，因为实际游玩时可能会有拍击完 Slide Star 的手不得不松开的情况，例如下图的一笔画 `{8}1<5[4:1],7,5>1[4:1],3,1,` 中，5>1 的 Slide Star 拍击后，由于另一只手正在划 1<5，因此必须松开去拍击 A3 的 Tap，这种情况下就不是软内无，而是标准的内屏无理：

![one_stroke_muri.png](https://raw.githubusercontent.com/Minepig/MaiMuriDX/master/docs/images/one_stroke_muri.png)

类似的还有七感 1:51 处的经典内无 `{4}1p3[4:1],3p5[4:1],5^2[4:1],2<6[4:1],`：

![7thsense.png](https://raw.githubusercontent.com/Minepig/MaiMuriDX/master/docs/images/7thsense.png)

```
[01:52F06.33] 内屏无理："5^2[4:1]"(L137,C50) 被提前蹭掉，相关判定区如下
    A5: "5_"(L137,C43)@01:51F42.33 (H+4.97, S-395.03, J-754.94, E-795.03)
    A4: Skipped
    A3: "3p5[4:1]"(L137,C38)@01:51F43.67 (H+27.19, S-372.81, J-732.72, E-772.81)
    A2: "2_"(L138,C7)@01:52F06.33 (H+404.97, S+4.97, J-354.94, E-395.03)
```

然而七感此处的一笔画在 MaiMuriDX 中报告的内无并不止此处及后续对称的两个，1 秒前的配置 `{4}7p1[4:1],1p3[4:1],3p5[4:1],` 也会被报告为内无：

![7thsense2.png](https://raw.githubusercontent.com/Minepig/MaiMuriDX/master/docs/images/7thsense2.png)

```
[01:51F18.33] 内屏无理："1p3[4:1]"(L137,C26) 被提前蹭掉，相关判定区如下
    A1: "1_"(L137,C19)@01:50F54.33 (H+4.97, S-395.03, J-746.73, E-795.03)
    B8: Skipped
    B7: "7p1[4:1]"(L137,C14)@01:50F57.67 (H+60.52, S-339.48, J-691.17, E-739.48)
    B6: "7p1[4:1]"(L137,C14)@01:50F58.67 (H+77.19, S-322.81, J-674.51, E-722.81)
    B5: "7p1[4:1]"(L137,C14)@01:51F01.67 (H+127.19, S-272.81, J-624.51, E-672.81)
    B4: "7p1[4:1]"(L137,C14)@01:51F04.33 (H+171.64, S-228.36, J-580.06, E-628.36)
    A3: "3_"(L137,C31)@01:51F18.33 (H+404.97, S+4.97, J-346.73, E-395.03)
```

从检测报告中得知，这里 1p3 被蹭掉的原理是 7p1 蹭到了 B7 区，这在先前“正规手法”的叙述时也有提到，由于 B7 不属于 7p1 的判定队列，这个配置通常不被认为是内无。然而正如之前所提到的，**Slide 的正规手法是划动**，而 7p1 沿轨迹划动极易蹭 B7，因此 MaiMuriDX 将此配置一并报告为内无（而且这样代码好写），从某种意义上这也可以称作一种软内无，因为并不难规避，只要不严格照着轨迹划稍微往旁边让开一点就可以，不过这就需要看内屏灵敏度的脸色了。

类似的还有 `{4}1p4[8:1]*q6[8:1],1w5[8:1],` 的 Wifi 内无（注意 Wifi 有三个独立的判定队列）：

![wifi_muri.png](https://raw.githubusercontent.com/Minepig/MaiMuriDX/master/docs/images/wifi_muri.png)

```
[00:14F52.00] 内屏无理："1w5[8:1]"(L8,C32) 被提前蹭掉，相关判定区如下
    A1: "1p4[8:1]"(L8,C14)@00:14F39.67 (H+3.11, S-496.89, J-702.80, E-746.89)
    B2: "1q6[8:1]"(L8,C23)@00:14F42.67 (H+53.11, S-446.89, J-652.80, E-696.89)
    B1: "1q6[8:1]"(L8,C23)@00:14F42.00 (H+42.00, S-458.00, J-663.91, E-708.00)
    B8: "1p4[8:1]"(L8,C14)@00:14F42.67 (H+53.11, S-446.89, J-652.80, E-696.89)
    B3: "1q6[8:1]"(L8,C23)@00:14F45.00 (H+92.00, S-408.00, J-613.91, E-658.00)
    C: Skipped
    B7: "1p4[8:1]"(L8,C14)@00:14F45.00 (H+92.00, S-408.00, J-613.91, E-658.00)
    D5/A4: "1p4[8:1]"(L8,C14)@00:14F52.00 (H+208.67, S-291.33, J-497.24, E-541.33)
    B5/A5: "1q6[8:1]"(L8,C23)@00:14F48.67 (H+153.11, S-346.89, J-552.80, E-596.89)
    D6/A6: "1q6[8:1]"(L8,C23)@00:14F52.00 (H+208.67, S-291.33, J-497.24, E-541.33)
```

由于 DX 框体中 Wifi 不再强制要求 C 区的松手判，上述配置中 Wifi 的 1-5 部分可以在 B1 被 1p4 或 1q6 蹭到以后再摸 B5 跳过 C 区完成，构成内屏无理。当然实际上机时 1p4\*q6 配置在处理时可能会被当成 1-4\*-6，这样就不会触碰 B5，B1 也可以稍加注意避开，因此 Wifi 不一定会被蹭掉。

一笔画配置还有一种容易导致内无的情况，是在 BPM 较低且 Slide 速度较慢的时候，下一条 Slide 的 Slide Star 拍击时，上一条 Slide 已经划至倒数第二区，此时内屏拍击 Slide Star 就会触发跳区导致蹭 Slide，例如 `{1}1<5[1:1],5>1[1:1],` 这种配置：

![one_stroke_muri2.png](https://raw.githubusercontent.com/Minepig/MaiMuriDX/master/docs/images/one_stroke_muri2.png)

当 5>1 的 Slide Star 到达时，1<5 已经划到了 A6 区，此时 A5 拍击 Slide Star 就会蹭掉 5<1，如果 BPM 足够低（经计算理论上是低于 148），那么此时 5<1 就不处于 Critical Perfect 区间，就会导致内屏无理。这种情况在 MaiMuriDX 的报告中不会输出所有的判定段，只会输出从此时 Slide 应当已经处理到的判定区开始一直到结尾的所有判定段情况：

```
[00:16F09.67] 内屏无理："1<5[4:4]"(L8,C15) 被提前蹭掉，相关判定区如下
    A6: "1<5[4:4]"(L8,C15)@00:15F59.00 (H+1825.33, S+1325.33, J-524.34, E-674.67)
    A5: "5_"(L8,C24)@00:16F09.67 (H+2003.11, S+1503.11, J-346.56, E-496.89)
```

内屏无理还有一个经典案例，白人打架 1:47 处 `(162){24}1/4,2/5,3/6,4>1[8:1]/7<4[8:1],` 纯内会蹭 7<4：

![Alea jacta est! Remaster.png](https://raw.githubusercontent.com/Minepig/MaiMuriDX/master/docs/images/Alea%20jacta%20est!%20Remaster.png)

```
[01:47F24.67] 内屏无理："7<4[8:1]"(L74,C64) 被提前蹭掉，相关判定区如下
    A7: Skipped
    A6: "6"(L74,C46)@01:47F21.67 (H-46.30, S-416.67, J-583.29, E-601.85)
    A5: Skipped
    A4: "4_"(L74,C48)@01:47F24.67 (H+3.70, S-366.67, J-533.29, E-551.85)
```

从检测报告可以得知，这里 A6 区在击打 7<4 的 Slide Star 前 46.30 ms 就已经发生判定跳过了 A7。这个现象被称为 Slide 入判，**Slide 开始接受判定的时刻比 Slide Star 正解时刻提早了 100 ms**，也就是说在击打 Slide Star 的 100 ms 之前，Slide 就接受判定了。100 ms 也就是 6 帧，或者说是 150 BPM 的 16 分。而白人打架的 BPM 是 162，24 分扫键下 A6 区 Tap 只比 Slide Star 提前 61.73 ms，自然就把 Slide 蹭没了。

> 其实 Slide 入判只有 50 ms，但是 DX 框体自带了 +3.0 的 B 判用以弥补输入延迟，所以 Slide Star 前 100 ms 出现的 Tap 在获得 Critical Perfect 的时候时间实际上已经来到了 Slide Star 前 50 ms 了，这两者叠加造成了 100 ms 入判的现象。

紫黑人打架 1:50 的配置 `{16}7b,6/8,1/5<8[32:3],` 由于是 16 分扫键，A6 的 Tap 在 5<8 的 Slide Star 前 92.59 ms，比较极限，相对来说不太容易蹭：

![Alea jacta est! Master.png](https://raw.githubusercontent.com/Minepig/MaiMuriDX/master/docs/images/Alea%20jacta%20est!%20Master.png)

另外，因为这里是扫键，很显然上机游玩时手不会在击打 Tap 后立即抬起，而是会在 A 区滞留一段时间。MaiMuriDX 对于扫键的处理是基于 Maimai 最快的扫键白 Sun Dance 的 102 BPM 96 分扫，通过定义抬手延迟 22.22 ms，来部分模拟实际扫键时的判定区激活情况。实际上这段时间的具体长度可以用 A 区与 D 区的宽度比例计算：A 区大概占 45°角的 60%，所以可以大体上认为扫键间隔的前 60% 时间内 A 区是按下的状态。

再比如紫皇帝 1:02 处 `{8}3-5[8:1],,3/5,6-4[8:1],`，6-4 拍击 Slide Star 的时刻恰为 3-5 结束的时刻，紫皇帝 BPM 是 240，此处的 3-5 可以近似看作 `{16}3,4,5,` 的 16 分扫键，间隔 93.75 ms，同样卡在 100 ms 临界点附近。由于只有 3-5 触碰到了 A4 区，这个配置若要蹭掉 6-4 要求在 6-4 接受判定的时候 3-5 恰好划至两区中间，拥有一定面积的手同时激活了 A4 与 A5，这其实是比较苛刻的。MaiMuriDX 在默认参数下对这个配置没有检查出内无，但如果将手的半径增大至 55 px（直径 110 px 约合 5.5 cm），6-4 就会被蹭掉。

 ![the EmpErroR 2.png](https://raw.githubusercontent.com/Minepig/MaiMuriDX/master/docs/images/the%20EmpErroR%202.png)

对于这类 Slide 入判导致的跳区，个人建议是按照 Slide Star 正解时刻前 100 ms 内第二个判定区上有 Tap 会导致跳区来处理。但实际上机体验中这类配置蹭掉 Slide 的情况受环境条件影响较大（例如手的接触面积，实际扫键速度，内屏的灵敏度与输入延迟等），MaiMuriDX 对于这种 Edge case 暂时没有万全的检测手段。

还有一类双押导致的内无，例如下图中的 `{8}1>4[8:1]/3,4,` 和 `{8}1<5[8:1]/7>3[8:1],35,`。这种配置 Slide 会不会蹭要看双押的脸色，以左图为例，若击打双押时 A3 比 A1 更晚松手，那么就会触发跳区导致蹭 Slide，但如果 A3 比 A1 松的早就不会蹭。如果说左图可以通过击打 Slide Star 不松手来完全规避，那么右图的配置就几乎是必蹭一条 Slide 了，A1 和 A7 哪边先松开那边的 Slide 就会蹭掉，除非同帧松手，但这并不是很有可操作性。

![each_muri.png](https://raw.githubusercontent.com/Minepig/MaiMuriDX/master/docs/images/each_muri.png) ![each_muri2.png](https://raw.githubusercontent.com/Minepig/MaiMuriDX/master/docs/images/each_muri2.png)

MaiMuriDX 最初的版本无法检测到这种内无，因为程序生成的动作中所有双押肯定都是同时松手的。为了把这种配置纳入报告范围，MaiMuriDX 微调了 Slide 跳区规则：允许本帧内刚刚松开的判定区也触发跳区，因此左图的配置同时松 A1、A3 会直接跳区到只剩 A4。这种处理方式相当于让 Slide 以尽可能容易导致跳区的方式处理所有的双押，不过带来的副作用是，右图的检测结果中两条 Slide 会一起蹭掉，实际上机通常是不会发生这种情况的，不过无伤大雅。

至此，内屏无理的情况基本上分析完了，需要注意的是，一切内无的判定都要基于**提前蹭掉不会达成 Critical Perfect 的原则**，也就是说相同配置并不是在所有 BPM 下都会判为内无，如果 BPM 较高时能稳定蹭黄，那么就不算无理，仅在 BPM 低的情况下算作无理。

> 已知问题：下图的配置会被误判为内无，因为 TouchGroup 被处理成了用覆盖所有 Touch 的最小圆作为手掌的按压范围，在下列配置中这个圆覆盖了整个屏幕，于是就把 Slide 蹭没了。这个误判暂时没有很好的解决方法。（使用两个最小圆覆盖给定点的问题疑似是一个 NP-Hard 问题，但考虑到 Maimai 的 TouchGroup 要求相邻，或许有比暴力搜索更好的方法，但我不知道）

![false_positive_muri.png](https://raw.githubusercontent.com/Minepig/MaiMuriDX/master/docs/images/false_positive_muri.png)

### 叠键无理

叠键无理，顾名思义，两个 Note 叠在了一起导致无法同时处理。叠键无理原本是算入内屏无理的一部分，但由于和上述内屏无理的原理区别过大因此被单独拆分出来。

最早的叠键无理是 maimai PLUS 的宴谱 Turn around \[蛸]，如下图：

![Turn around 蛸.png](https://raw.githubusercontent.com/Minepig/MaiMuriDX/master/docs/images/Turn%20around%20蛸.png)

在 Hold 同键位出现了 Tap，这种配置是必须用内屏和外键一起处理的，可以按住外键处理 Hold，击打内屏来完成 Tap，反之亦然。这种配置在常规谱面中被认为是无理配置。

类似的还有 Slide 占用某一个 A 区时出现了 Tap 形成叠键：

![slide_over_tap.png](https://raw.githubusercontent.com/Minepig/MaiMuriDX/master/docs/images/slide_over_tap.png)

在 Slide 速度很慢的情况下，这种配置不会构成撞尾（Slide 进入 A5 区时 Tap 还远远未开始判定），但是在正规手法下，Slide 占用 A5 区时 5 号键的 Tap 只能外键击打，叠键无理还有下列配置：

![slide_over_touch.png](https://raw.githubusercontent.com/Minepig/MaiMuriDX/master/docs/images/slide_over_touch.png)  ![double_tap.png](https://raw.githubusercontent.com/Minepig/MaiMuriDX/master/docs/images/double_tap.png)
![touch_tap.png](https://raw.githubusercontent.com/Minepig/MaiMuriDX/master/docs/images/touch_tap.png) ![hold_touch.png](https://raw.githubusercontent.com/Minepig/MaiMuriDX/master/docs/images/hold_touch.png)

第一张图极慢 Slide 覆盖住了 Touch 其实可以勉强不算作无理，但是慢速 Slide 撞 Touch 的手感极其奇怪所以 MaiMuriDX 依旧把它归入无理配置（如果此处 Touch 的正解时刻恰好在 Slide 引导星星进入 A5 的时刻附近，那么 MaiMuriDX 会把它视作正常的 Slide 撞 Touch，不进行报告，但是依旧不建议这么写）。剩下三种配置可以说是多少沾点大病的，如果不是宴谱或者明确的观赏谱、整活谱的话没有什么写这种配置的理由。

需要注意的是，MaiMuriDX 在静态检查时对于叠键的检测阈值为 2 帧 33.33 ms，即同键位两个 Tap 之间间隔小于 33.33 ms 就会识别为叠键，这是由于 Maimai 判定帧率为 60 FPS，如果按键频率超过每秒 30 次的话就会被识别为长按。

### 撞尾无理与外键无理

外键无理，简称外无，与内无相对，原指全外键正攻时无法达成理论值的配置。在排除了与内无重合的部分以后（即绝对无理配置，如叠键或者 Slide 被 Touch 蹭绿），外无还剩余一种情况：Slide 启动后一定时间内出现同头 Tap 或 Hold。由于外键正攻时，划 Slide 需要先击打外键，再进入 A 区，相当于在 A1 位置上额外多了一次按下动作，多出来的这次按下就有可能蹭掉同头的 Tap 或者 Hold。

理论上如果一个人可以在击打外键后把手瞬移到 A 区，那么会蹭到 150 ms 内的同头 Tap 或 Hold。然而，根据一些来源不可考的实验结果，Maimai 的内屏比外键多了 2 帧输入延迟，假设这个结论正确，那么理论上必然造成外无的时间范围会拓宽到 183.33 ms，也就是说 163.6 BPM 以上的八分同头必定会造成外无。实际上由于手不可能瞬移，导致外无的时间范围还会进一步拓宽，经验上是以 200 ms 作为分界，即 150 BPM 以上的八分同头是外无。

撞尾无理，最早指 Slide 的终点上接着一个 Tap，如果 BPM 足够高，那么这个 Tap 就会被蹭掉。后来也用于代指 Slide 中间经过 A 区时蹭到 Tap 的情况，即“撞中间”。在 DX 框体中，抬手的过程也有可能在原位产生一个按下事件，即俗称的“抬手判 bug”，这也导致撞尾配置更难处理。

与外无类似的，撞尾无理的理论区间是以 Slide 的引导星星进入 A 区的时刻为起始的后 150 ms，由于 Slide 划动速度较为不确定，经验上会将区间拓宽到 200 ms。

从程序的角度考察，外无和撞尾的本质是一样的——外无就是起始 A 区上的撞尾（也许应该把外无称为”撞头“）。因此 MaiMuriDX 是将两者合并检测的，只根据是否为第一个 A 区来判断是外无还是撞尾。具体而言，在默认参数下 MaiMuriDX 把外无和撞尾定义为 Slide 的引导星星进入 A 区（含初始 A 区）时刻的 -50 ~ +200 ms，也即把 0 ~ +150 ms 的区间向两侧对称地拓宽了 50 ms，但向 Fast 方向拓宽时最多不超过 Slide 启动时刻。另外，对于最后一个区的撞尾，如果 Slide 速度较慢导致引导星星在最后一个区停留超过 150 ms，则会把区间拓宽到 Slide 结束时刻 +50 ms（相当于把默认的 0 ~ +150 ms 区间替换成了引导星星在最后一个区停留的总时间，然后对称拓宽 50 ms）。

下面举几个外无和撞尾的例子，首先是红 CYCLES 0:57 处 `{2}1/8^5[4:1],5/4^1[4:1],` 精准的三押和撞尾：

![cycles Expert.png](https://raw.githubusercontent.com/Minepig/MaiMuriDX/master/docs/images/cycles%20Expert.png)

红 CYCLES 的撞尾非常非常多，其中大多数是 Slide 结束后经过 16:1 时值接一个 Tap，刚好卡在 150 ms 的边界处，而上图中的配置更是重量级——Slide 结束的同时在终点出现一个 Tap。通常遇到撞尾，如果落在 150 ~ 200 ms 的区间里，可以通过加 Ex 保护来糊弄过去，不过对于上图中这种配置，普遍的认知是即使加了 Ex 保护也不会改变这是一个撞尾无理的本质。

白雷切 0:22 处的外无，`{8}4-2[8:1],4-7[8:1],4-8[8:1],4-6[8:1],4-1[8:1],4-8[8:1],4,4,` 在 165 的 BPM 下的八分同头 Slide，纯外键正攻基本上没有全 Perfect 的希望：

![雷切-RAIKIRI- Remaster.png](https://raw.githubusercontent.com/Minepig/MaiMuriDX/master/docs/images/雷切-RAIKIRI-%20Remaster.png)

和撞尾类似，外无配置通常允许加 Ex 保护糊弄过去，但需要注意保护的 Note 是哪一个。例如油乳膏 0:38 处 `{8}8x,8<5[8:1],8,8x,8>3[8:1],8,8x,8-4[8:1],8,8x,`虽然套了保护，但套的是 Slide 启动拍的 Tap，这个 Tap 是不会蹭的，会被外无蹭掉的 Tap 是下一个 Slide 的 Slide Star，而它没有保护（事实上这里会蹭的两个 Tap 正好都没有保护）：

![yourugao.png](https://raw.githubusercontent.com/Minepig/MaiMuriDX/master/docs/images/yourugao.png)

紫监狱 1:11 处 `{16}8,8-6[16:1],1,1-5[16:1],2-4[8:1],8b,,1b,,2b,` 的抢跑 Slide 在某些观念中可能也会被归入外键无理，因为是否把延迟划 Slide 算作是正攻比较有争议，MaiMuriDX 选择将抢跑 Slide 也纳入外键无理的范畴中：

![Panopticon.png](https://raw.githubusercontent.com/Minepig/MaiMuriDX/master/docs/images/Panopticon.png)

另外，MaiMuriDX 没有读取 Note 的具体性质，因此所有的 Ex-Note 都会被当作普通 Note 看待，所以会出现下面这种带保护的 Note 被蹭掉的报告，属于 Intended Behavior：

```
撞尾无理："8x_"(L20,C6) 可能被 "4-8[8:1]"(L19,C75) 蹭到 (+173.57 ms)
```


## MaiMuriDX 工作流程

MaiMuriDX 的工作流程可以大致分为四个步骤：谱面读取，动作生成，静态检查和动态检查。

谱面读取的过程是将 Simai 语读取转变为 Note 对象序列；动作生成是针对每一个 Note 对象，生成对应的 Action 对象来模拟正规手法；静态检查是根据 Note 对象序列检查只需要考虑 Note 时机的无理配置，包括外无、撞尾和部分的叠键；动态检查则是实际进行逐帧的模拟，将 Action 应用在 Note 上并计算判定结果，以此检查无理。

### 文件内容概述

下面概括了每个文件中定义的内容，具体每一项内容可以看文件注释（但是是中英混合的）

- `svg.parser`、`svg.path`
	- Github 上搬下来的第三方模块，原仓库在 https://github.com/regebro/svg.path
	- 我对里面的内容有过少量的修改（有个东西漏个负号给他补上之类的）
- `core.py`
	- 无理检查时用到的所有常数
	- 33 个判定区的 Enum 对象及相关函数
	- 3 个判定结果的 Enum 对象
	- 注：MaiMuriDX 把点的坐标用复数进行表示，原点通常是屏幕中心
- `slides.py`
	- 所有基本的 Slide 轨迹形状、判定队列、以及进入每个判定区的时间节点
	- 唯一使用到 svg 的模块
	- 用于旋转、镜像 Slide 轨迹的 Wrapper 类 `SlidePath`
	- 记录所有标准 Slide 信息的类 `SlideInfo` 和 `WifiInfo`
	- 注：MaiMuriDX 通常是把 Wifi 从 Slide 里单独分离出来处理的
- `simai.py`
	- 每一种 Note 类型，包含了基本信息和判定逻辑细节，最基础的基类是 `SimaiNote`
	- 由于 Hold 一定不会过早放手，Hold 和 TouchHold 只考虑了头判，因此和 Tap、Touch 区别不大，归入统一的基类 `SimaiSimpleNote`
	- 一组 TouchGroup 被当成了**单独一个 Note**，对应的类是 `SimaiTouchGroup`
	- 为了避免混淆，命名尽量避开“time”，时间段用“duration”，时刻用“moment”
	- 各种时间段、时刻的单位都为“tick”（1/180 秒），时刻的零点为 BGM 开始
	- 每个类型的实例属性的具体含义可以看注释，没有注释的话就看变量名就足够
- `action.py`
	- 三种不同的动作：长按、划动、外无的额外激活
	- 逻辑不复杂，看函数的docstring应该足够了
- `majparse.py`
	- 存放了用来翻译 Simai 语的函数
	- 把 Note 序列转化成 Action 序列也在这里
	- 代码比较史，具体逻辑下面会有详细介绍
- `judge.py`
	- 静态无理检测与动态无理检测的核心逻辑
	- 核心内容只有 `StaticMuriChecker.check()` 和 `JudgeManager.tick()`
	- 具体逻辑下面会有详细介绍
- `render.py`
	- 渲染相关逻辑
	- 同时也是唯一使用到了 pygame 的模块
	- 对于移植没什么用，之后也没有优化和更新的计划
- `util.py`
	- 杂项工具函数，目前只有用来找最小覆盖圆的算法
- `main.py`
	- 窗口模式运行的主程序
- `cli.py`
	- 命令行接口的主程序

### 谱面读取

谱面读取部分大体上是照搬 MajdataEdit 的逻辑，外加大量魔改，因此 Majdata 支持的内容 MaiMuriDX 几乎都支持。这部分的入口函数在 `majparse.py` 的 `SimaiParser.parse_simai_chart()`。`SimaiParser` 的其他函数都为 protected（Python 里以单下划线起始的函数），功能如下：

- `_parse_hold_duration()` 用于翻译 Simai 语中 Hold 的时间标记
- `_parse_slide_wait_and_duration()` 用于翻译 Simai 语中 Slide 的时间标记
- `_parse_slide_note()` 用于解析 Slide，会被 `_parse_note()` 调用
- `_parse_note()` 用于解析所有 Note
- `_workup_each()` 在解析完一组 Each 以后，对其进行后处理，目前仅用于生成 TouchGroup
- `_post_parse_workup()` 解析完整张谱面以后的后处理，例如标记拍划 Tap、Slide 撞 Touch 等
- `_check_touch_on_slide()` 与 `_check_touch_on_wifi()` 检查 Slide 撞 Touch

`parse_simai_chart()` 首先会将谱面文件分行处理，生成行号和列号，BPM 定义和拍号定义会被记录，注释、HS 定义、空白字符则会被直接忽略。

> 注释是 Majdata 的自创语法，以双竖线 `||` 引导直到行尾
> HS 是 Majdata 的自创语法，允许临时修改 Note 下落速度实现超车

每当读到 `12345678ABCDE` 中的任何一个字符，意味着有一个 Note 将要被读取，记录后续所有字符直到出现`` ,`/ ``这三个标志 Note 结束的字符，此时会尝试把记录的字符串解析成若干 SimaiNote 对象，然后如果结束标志不是 `/` 还需要将当前的 Each 列表进行后处理后并入解析结果，然后清空 Each 列表，在读到 `,` 的情况下，根据 BPM 和拍号计算当前时刻的变化。

> 伪双在 Majdata 中用 128 分音，在 Simai 标准中用 1 ms 延迟，在 Maimai 中一般用 384 分音
> 在 MaiMuriDX 中，伪双会被直接忽略记作双押，除了不会形成 TouchGroup 以外与 Each 无异 

在尝试解析 SimaiNote 时，例如 b、x、f 等 Note 特征都会被直接忽略，假 Hold（不带时间定义的 Hold，如 `6h`）也会直接被解析成 Tap。解析 Slide 时，Slide Star 会被当做单独的 Tap 与 Slide Track 分离，Slide Track 的解析首先会在 `*` 处进行同头 Slide 的拆分，然后将每一段单独解析。

> 注意：MaiMuriDX 不支持 Wifi 的串联，例如 `1w5w1w5` 在 MajdataView 里可以正常渲染，但是 MaiMuriDX 无法解析，而 `1-5w1` 这种普通 Slide 与 Wifi 的混合 MajdataView 也无法正确渲染。

之所以忽略 Note 特征是因为 MaiMuriDX 要求 DX 分理论，于是 Break Note 和普通 Note 就没有差异了，而通常来说使用 Ex 保护逃避无理配置并不是很好的行为，因此 MaiMuriDX 选择不读取 Ex 保护的属性，剩余的 Note 特征如 f、$、@ 等只有视觉效果的差异，故也不做区分。

每当读完了一组 Each 以后，会将这一组 Each 进行后处理，将其中的 Touch 单独分离出来，根据判定区的相邻关系，利用类似并查集的算法组合成若干个 TouchGroup，对于含 2 个及以上 Touch 的 TouchGroup，会创建 `SimaiTouchGroup` 对象代替原本的 `SimaiTouch` 对象放入 Note 序列。 

在整个谱面全部解析完成后，还会再次做一遍后处理，筛出以下特殊配置，并在相应的实例属性里加以记录，供动作生成时使用：

- 拍划配置的 Tap，调用 `set_slide_head()` 标记；
- 被 Slide 撞到的 Touch，调用 `set_on_slide()` 标记；
- 一笔画配置中，前后两条 Slide 分别调用 `set_before_slide()` 与 `set_after_slide()` 标记。

类似相信彩虹的重叠 Slide 也会被算进一笔画，检测算法是某一条 Slide 的终点处有另一条 Slide 划到了相同位置，且移动方向也一致，则这条 Slide 也需要调用 `set_before_slide()` 标记。准确的说，`set_before_slide()` 标记了所有划完以后不需要松手的 Slide（因为要顺着一笔画继续划），而 `set_after_slide()` 恰好相反，标记了所有划之前没有“按下”动作的 Slide（因为手已经按在内屏上划前面的 Slide 了）。

### 动作生成

在谱面读取完成后，会对生成的 Note 对象序列里每一个 Note 逐一生成正规手法的动作，得到一个 `Action` 对象的序列。入口函数在 `majparse.py` 的 `NoteActionConverter.generate_action()`，由于绝大多数工作在谱面读取时已经完成，此处的逻辑很简单：

- 对于 Tap，如果被 `set_slide_head()` 标记过，不生成 Action，否则在所在判定区中心生成常规半径，按压时长为 0 的按压动作 `ActionPress`（注意 `ActionPress` 初始化时会默认给按压时长增加等同于抬手延迟参数的时间，因此虽然初始化时传入的按压时长是 0，但实际上在默认设置下得到的按压动作有 22.22 ms 的时长，下文不再赘述）；
- 对于 Touch，如果被 `set_on_slide()` 标记过，不生成 Action，否则在所在判定区中心生成常规半径，按压时长为 0 的按压动作 `ActionPress`；
- 对于 TouchGroup，读取谱面时已经预先算好了覆盖所有 Touch 的最小圆，因此除非整个组内所有 Touch 都被 `set_on_slide()` 标记过一遍，否则都会根据计算好的最小圆圆心和半径，生成一个按压时长为 0 的按压动作 `ActionPress`；
- 对于 Hold 和 TouchHold，在所在判定区中心生成常规半径，按压时长为 Note 持续时间的按压动作 `ActionPress`；
- 对于 Slide，如果没有被 `set_after_slide()` 标记过（也就是划的时候确实需要按下），则首先生成用于模拟外键正攻时额外触发 A 区的动作 `ActionExtraPadDown`，否则不生成；然后根据组成连锁 Slide 的各段路径，逐段生成常规半径，划动时长依次为每一段的持续时间的划动动作 `ActionSlide`，且除了最后一段外都没有抬手延迟；最后，如果没有被 `set_before_slide()` 标记过，再给最后一段的动作加上抬手延迟，反之保持无抬手延迟的状态；
- 对于 Wifi，处理方式类似普通 Slide，没有被 `set_after_slide()` 标记过时需要生成 `ActionExtraPadDown`，然后生成两条从起点指向正对面两个 D 区的划动动作 `ActionSlide`，且半径比通常更大，由于 Wifi 后面不可能接其他 Slide，故一定会有抬手延迟。

全部生成完成后，再对整个动作列表根据动作起始时间排序一次。每一个生成的 Action 对象都保有产生它的那个原始 Note 的引用，这是为了在后续生成检测报告时可以溯源。

### 静态检查

静态检查部分由 `judge.py` 中的 `StaticMuriChecker.check()` 完成，目的是检查动态检查中不易查出的外键无理和撞尾无理，顺便也检查一部分的叠键无理。

静态检查中涉及的叠键无理是 Tap/Hold/Touch/TouchHold 之间的叠键，不包含 Slide，当两个 Note 占用同一区域的时间间隔不足 2 帧时，认为出现了叠键。

> 原本设置的默认参数里叠键阈值是 3 帧，但这会导致官谱白系的 177.6 BPM 32 分纵连和 Latent Kingdom 的 201 BPM 24 分纵连也被识别为叠键，尽管这种必须内外一起掐的高速纵连确实可以被认为是叠键，但我还是决定放宽一点。

外无和撞尾就按前文提到的检测方法：逐个判定区检测，如果是 A 区，就检测是否有 Tap/Hold 出现在危险区间中，若有，那么对于起始 A 区而言这是外键无理，对于其他 A 区而言是撞尾无理。

计算危险区间时采用的方法是：

- 首先计算设置的撞尾阈值（默认为 200 ms）与 150 ms 的差值；
- 计算理论危险区间：通常是 0 ~ +150 ms，如果是最后一个区，且引导星星在最后一区停留超过 150 ms，就延长区间 Late 侧端点至 Slide 结束时刻；
- 将上述理论危险区间向两侧延伸等同于差值的时间（默认参数下会得到 -50 ~ +200 ms，最后一个区会延长至 Slide 结束 +50 ms）；
- 如果区间的 Fast 侧端点早于 Slide 启动时刻，则修正为 Slide 启动时刻。

对于 Wifi，终点的三个 A 区采用一样的危险区间。


### 动态检查

动态检查是 MaiMuriDX 的核心功能，通过模拟正攻计算判定来检查无理配置，由 `judge.py` 中的 `JudgeManager.tick()` 完成，这个函数在开启了渲染窗口的情况下，会尝试以最高 200 tps 的速度循环执行，即每秒执行 200 次 `tick()`。若时间不够的话会降低 tps，以尽量保证谱面的渲染和 BGM 不会不同步。

由于我的代码并没有做过多优化，因此在开启了渲染窗口时，如果电脑性能不太好可能会导致检测效果不佳（如果跑不满 60 tps 的话结果基本上不可靠）。这种情况建议关闭渲染功能进行检测，通过延长总执行时间保证检测可靠性（当然电脑性能很好的情况下，关闭渲染功能则可以缩短运行时间，因为不需要等 BGM 了）。

`tick()` 的流程中，首先会把 2 s 以内会出现的 Note 和 Action 单独放入活动列表（一些优化的目的）。接下来计算本 tick 内的触摸状态，首先会计算出各触点的位置与半径，然后计算触点与各判定区的圆的位置关系，得到本 tick 激活的判定区。然后就可以和上 tick 激活的判定区做比较得到本 tick 的按下事件和松开事件，之后就可以具体计算判定了。

为了便于计算判定，在更新触摸状态时需要维护三个字典：

- `pad_source_dict`：记录每个判定区是否被按下，若是，由于哪个动作按下；
- `pad_up_source_dict`：记录每个判定区是不是刚刚松开，若是，之前按下是由于哪个动作；
- `pad_down_source_dict`：记录所有刚刚按下的判定区，及其由于哪个动作按下。

这里需要注意，`pad_down_source_dict` 后续的用法与另外两者不同。另外两个字典主要用于 Slide 的判定计算，需要作为 lookup 使用，因而需要把全部 33 个判定区都记录其中，用 `None` 来标记没有被按下/没有刚刚松开的判定区。而 `pad_down_source_dict` 用于非 Slide 类型 Note 的判定计算，通过迭代所有键值对来产生“按下事件”传递给每一个 Note，因此只能记录那些确实在本 tick 刚刚按下的判定区。也因此，这个字典的初始化是空字典，而另两个则是初始化为存了 33 个 `None`。

`ActionPress` 和 `ActionSlide` 会给出本 tick 内的触点位置、半径、运动方向。如果一个 Action 的 `merge_key()` 函数给出的不是 `None`，那么相应的触点就会尝试与相同 `merge_key` 的触点合并。合并的具体规则要求：圆心距离小于合并阈值距离（默认设置为 20 px），且运动方向角度差小于合并阈值角度（默认设置为 3°）。这是为了实现“路径重合的 Slide 不算作多押”。目前普通 Slide 的触点之间可以合并，Wifi 的触点之间也可以合并，但不允许普通 Slide 和 Wifi 的触点合并，也不允许任何 `ActionPress` 的触点参与合并。`ActionExtraPadDown` 则会在这一步中额外生成按下事件，这是通过直接给 `pad_down_source_dict` 增加元素完成的。

在生成完本 tick 内所有的触点以后，对每一个触点计算与各判定区的相交情况，得到本 tick 内的判定区激活状况。由于 MaiMuriDX 使用圆形来近似每一个触点和判定区，这里其实只需要比较圆心距和半径和的大小关系。这一步还会检查多押无理，因为每一个触点的来源 Action 是已知的，可以得知每一个触点对应几只手（目前只有 TouchGroup 触点可能会需要两只手），将手的数量求和后观察是否大于 2 以判断是否构成多押无理。若构成了多押，则将本 tick 内所有触点溯源到 Note，记录到检测报告中。

接下来将本 tick 内的激活状况与上一 tick 比较，得到有哪些判定区是刚刚按下，哪些判定区刚刚松开。然后就可以计算 Note 的判定了，首先会把所有的按下事件按照时间顺序依次传递给当前激活的所有 Note，如果某个 Note 使用一个按下事件完成了判定，那么事件就会被消耗掉，不继续传递。Note 应对按下事件的函数是 `SimaiNote.on_pad_down()`，Slide 和 Wifi 完全不响应，而 Tap、Hold、Touch、TouchHold 的响应方式都是一样的，在 `SimaiSimpleNote.on_pad_down()` 中，若当前时刻在判定区内，就消耗掉事件并计算判定结果，由于 MaiMuriDX 只关心每个 Note 有没有达到 Critical Perfect，所有非 Critical 判定全部会被当作 Good（包括 Miss）。注意 Hold、TouchHold 与 Tap、Touch 的差异仅有生成的 Action 以及渲染，它们在判定上其实是完全一致的。TouchGroup 会将收到的事件依次传递给组内 Touch，一旦有一个消耗了事件就停止传递。

再接下来，对每一个激活的 Note 进行例行的更新，对于 Tap、Hold、Touch、TouchHold 而言，这里只需要检查是不是已经 Too Late 了。TouchGroup 除了更新组内的 Touch 以外，还需要观察是不是已经有超过半数的 Touch 完成了判定，若是，将剩下的所有 Touch 在本 tick 内一起判定掉。而 Slide 和 Wifi 在这一部分是主要判定的逻辑，接下来详细说明。

Slide 的更新逻辑入口在 `SimaiSlideChain.update()`，首先检查是不是已经判定过或者还未接受判定，接下来会反复检查并更新判定队列，直到不产生变化为止，然后若此时已经完成了整条队列，计算判定结果，最后再检查 Too Late。检查并更新判定队列时，使用到一个实例属性 `pressing` 存储当前正在按下的判定区（若当前没有按下判定区则为 `None`）。判定队列检查流程如下：

1. 如果当前没有按下任何判定区（`pressing` 是 `None`），则检查当前队列中的首个判定段，如果首个判定段中的判定区被按下，将该判定区记录到 `pressing`，然后从头开始重新检查；
	- 如果此时已经是最后一个判定段，则立刻完成该判定段；
2. 如果已经有一个判定区被按下（`pressing` 不是 `None`），检查该判定区是否松开，松开后完成当前首个判定段，把 `pressing` 置为 `None`，然后从头开始重新检查；
3. 如果当前首个判定段允许跳区，检查下一个判定段，若其中某个判定区被按下**或者本 tick 内刚刚松开**，将该判定区记录到 `pressing`，立刻完成首个判定段，然后从头开始重新检查；
	- 同样，如果下一个判定段已经是最后一个判定段，也会立刻完成这个判定段；
4. 上述三项检查如果任一项命中，意味着队列状态发生了改变，检查也会重新开始，因此如果到达了这一项，意味着队列状态不再改变，于是可以结束本 tick 的检查了。

上述流程中的“首个判定段”是使用一个列表的下标来标记的，因此“完成判定段”就是将该下标增加 1 使下一个判定段成为新的“首个判定段”。每个判定段在按下时，会把导致按下的 Action（这在之前的判定区状态计算过程中记录了下来）与按下的时刻记录到一个列表供后续溯源使用。

用于判断是否可以跳区的规则如下：

1. 有判定区被按下（`pressing` 不是 `None`），一定可以跳区，这条规则优先度最高；
2. 如果不是 Festival 的连锁 Slide，那么如果是转折 Slide（大 V Slide），则正数第二个区不允许跳过，如果此时终点在起点的对径点（例如 1V35），正数第四个区也不允许跳过；
3. 所有不符合第 2 条的 Slide，判断初始判定队列的总长度，若长度为 4 及以上，一定可以跳区，若长度为 3 及以下，倒数第二个区不允许跳区。

Wifi 的更新逻辑类似 Slide，区别在于因为有三条独立判定队列，需要依次检查，而且因为每一条判定队列的长度都是 4，所以每一个区都能跳过。如果三条判定队列都已完成，计算判定结果。

在所有 Note 全部更新完毕以后，把已经完成了的 Note 移出活动队列，移出的过程中可以检查 Note 的判定结果，如果不为 Critical，就认为是出现了无理。具体而言，Slide 与 Wifi 的非 Critical 视为内屏无理，其他 Note 的 Fast 视为外键无理或撞尾无理（如果是 `ActionExtraPadDown` 导致的无理就是外键无理，其他情况全部视作撞尾无理），Late 则视为叠键无理（因为正攻不可能 Late，如果 Late 了说明该按的时候被别的 Note 占用了判定区没按上）。


## 附录：Maimai 判定全解

本部分内容大量参考 墨滢-moying 的专栏（cv18132542、cv18133076、cv18134919），并且已将其中没有涉及到或是过时的部分进行了补充和修正。本部分所述内容是日版 Maimai DX Buddies（以及中国大陆版 舞萌 DX 2024）版本的判定全解，若与旧版本框体中的内容有出入，以 Buddies 版本为准。

### 基本名词

在 Maimai 中有很多经常被提到的物件，这些物件在玩家交流时有约定俗成的专有名词来代指，此处介绍其中不易归类的一部分，另一部分会在后续内容中加以解释。

Maimai 机台硬件相关：

- 外键：指 Maimai 屏幕外的 8 个按键，可以用于击打 Tap、Hold 这两种 Note。
- 内屏：指 Maimai 的圆形屏幕，可以用于击打一切 Note。
- 副屏：指 Maimai 上方的长方形小屏幕，在实际游玩中没有功能，仅作为显示器使用。

下图为 Maimai 现行框体外观：

![maimai_budplus.png](https://raw.githubusercontent.com/Minepig/MaiMuriDX/master/docs/images/maimai_budplus.png)

Maimai 游戏内物件相关：

- Note：或称音符，泛指游戏中出现的 Tap、Hold 等等一切需要玩家做出相应操作的物件。
- 判定结果：指一个 Note 在玩家处理完后得到的 Critical Perfect、Perfect、Great、Good、Miss 五种结果的统称，用来衡量玩家击打 Note 的准确度。
- 谱面：在音乐的不同节拍点放置各种 Note 的组合，得到的结果就是一张谱面。
- 达成率：用以衡量玩家游玩一张谱面的成绩，根据谱面中每一个 Note 的判定结果进行赋分并加权平均后计算得到，最低 0%，最高 101%。
- DX 分：另一种衡量成绩的方式，计算方式与达成率不同。
- 理论值：即满分，通常所说的理论值是指达成率满分，也即 101%，此时 DX 分一般不会是满分，如果特指 DX 分达到满分（此时达成率必然是 101%），会说“DX 理论值”。

### 判定区与判定线

Maimai 的内屏并不是一块均匀的触摸屏，而是被划分为了 34 个判定区，游戏永远把一个判定区视作一个整体，换言之，无论按压一个判定区的边缘还是中心，都会被视为对整个判定区的操作，无法具体区分。34 个判定区的具体划分如下图：

![judge_areas.png](https://raw.githubusercontent.com/Minepig/MaiMuriDX/master/docs/images/judge_areas.png)

判定区被划分为 A、B、C、D、E 共 5 个类型，除了 C 以外，其余的类型均有 8 个判定区。我们分别在字母后面标注数字，如 A1、D5、E3 等，来表示他们。C 虽然包含了 C1、C2 两个判定区，但在实际游玩谱面时，这两个判定区永远都是被合并看待的，只在例如选择歌曲时有不同的功能。因此大多数情况下，会把 C1、C2 合并成 C 来看待，这样就只有 33 个判定区了。

A 区和 B 区是和外键位置对齐的，因此外键也会被赋予编号，例如“2 号键”指正对着 A2 区的外键。D 区和 E 区则在相同编号的外键逆时针方向 22.5° 处。

每一个判定区均有两种状态，**按下状态**（ON）以及**松开状态**（OFF）。除此之外，游戏不关心判定区的任何其他细节。判定区的其他任何功能也都是根据这两种状态来实现的。当判定区由 OFF 状态转变为 ON 状态时，我们称该判定区发生了**按下事件**（DOWN）；当判定区由 ON 状态转变为 OFF 状态时，我们称该判定区发生了**松开事件**（UP）。因而，从空中拍向判定区和从旁边滑到判定区是等价的，将手离开屏幕和将手移出判定区也是等价的。

类似的，每一个外键也都有**按下状态**以及**松开状态**，以及**按下事件**和**松开事件**，而且与相对应的 A 区是完全无关的。

Maimai 对判定区和外键的监控是以帧为单位的，且固定每秒 60 帧。假如在第 N 帧，A1 处于 OFF 状态，而在第 N+1 帧，A1 处于 ON 状态。那么，就相当于在第 N+1 帧时，A1 发生了按下事件。

> 此处事件和状态都使用了“按下”和“松开”的名字，可能造成混淆，但是本文中所有相关位置都会写明是事件还是状态，或者上下文会有足够的信息来判断。

> 对于数字逻辑电路比较熟悉的读者，可以理解为：按下状态是高电平，松开状态是低电平，按下事件是上升沿，松开事件是下降沿。

判定线是上图外侧带有 8 个小圆点的白色圆形，判定线的作用是指示 Tap 和 Hold 应当被击打的时刻。Maimai 的内屏是一块 1080x1080 像素大小的圆形，而判定线是圆心在屏幕中央，半径为 480 像素的圆形。

### 基本 Note 类型

Maimai 中的 Note 一共可以分为 5 大类：Tap、Hold、Slide、Touch、TouchHold。这五种 Note 在下图中各有一个例子：

![notes.png](https://raw.githubusercontent.com/Minepig/MaiMuriDX/master/docs/images/notes.png)

#### Tap

上图 1 号键位置的是 Tap，Tap 是 Maimai 中最基础的 Note，它的击打规则十分简单：当 Tap 从中间向外侧移动至判定线时击打它。 

Tap 有很多种形态，如下图，它们拥有不同的外观、音效与计分方法，但是击打规则都是一样的。

![tap_all.png](https://raw.githubusercontent.com/Minepig/MaiMuriDX/master/docs/images/tap_all.png)

Tap 可以通过外键来击打，也可以通过内屏的 A 区来击打。当对应的 A 区接受到一次按下事件时，对应位置上的 Tap 将会被击打，并给出判定。

上面提到，按下事件是因为判定区由 OFF 状态转变为 ON 状态引起的。因此，举例来说，如果你用左手持续按压 A1 区，再用右手尝试触摸 A1 区，你右手的触碰将不会产生任何影响——因为 A1 已经处于 ON 状态了，它必须先变回 OFF 状态，再变为 ON 状态，才可以触发一次按下事件。

不过，Maimai 的外键和内屏彼此独立，当你击打外键时，内屏对应的 A 区不会接受到任何信号。因此，相同键位上的连续 Tap 可以通过一只手击打内屏、一只手击打外键的方式，来避免两只手之间的干扰，增加容错率。

#### Hold

上图 3 号键位置的是 Hold，它需要在头部移动到判定线时按住，并持续按压，直至其结束。

类似于 Tap，Hold 也可以通过外键和内屏的 A 区来击打，但 Hold 要求在持续时间内持续按压。如果中途松开，仍然可以再按回去继续完成Hold，但是最终的判定结果会有所下降，关于此特性的具体细节请见后文。Hold 没有松手尾判，即当 Hold 结束时，不松开手判定也不会下降。

虽然内屏与外键彼此独立，但是 Hold 允许你中途从外键转变为内屏操作：你可以先按住外键，然后按住内屏，再松开外键，Hold仍然会保持按住的状态而不受影响。

#### Touch

上图 B5 判定区出现的是 Touch，Touch 是 DX 版本加入的新 Note。不同于 Tap、Hold 的“下落式”，Touch 是“浮现式”的。他会从屏幕中浮现出来，并通过快门闭合来提示应当正确击打的时机，当 Touch 的 4 片快门完全闭合至中心的圆点处时击打内屏上对应的判定区即可完成 Touch。

Touch 出现的位置并非任意的，它只会出现在 33 个判定区的正中央，当对应的判定区发生了按下事件时，Touch 就会被击打。注意与 Tap 不同，Touch 即使出现在 A 区，也不可以通过外键来击打。

和 Tap 的内屏操作十分类似，如果一个判定区被按压住不松开，那么之后在这个判定区出现的所有 Touch 将都无法被正确触发。

Touch 可能会附带烟花特效。这种 Touch 的外观和其他 Touch 完全一致，但是当它获得 Miss 以外的任何一种判定时，就会发射出彩虹烟花特效，并发出音效。

#### TouchHold

上图中央的 C 判定区出现的是 TouchHold，TouchHold 是 Touch 的长按版本。在目前的所有官谱中 TouchHold 只会在屏幕中央（也就是 C 判定区）出现。和 Hold 类似，他也需要持续的按压、中途松开可以按回、没有尾判等。和 Touch 类似，TouchHold 也可能会附带烟花特效。当 TouchHold 结束时，如果其获得的不是 Miss 判定，那么就会发射出彩虹烟花特效，并发出音效。

#### Slide

上图左侧的箭头状轨迹是 Slide，Slide 是 Maimai 最具特色的 Note，它要求玩家在内屏上进行划动。Slide 分为开头的星星头 Slide Star 和滑条 Slide Track。他们彼此独立，不会相互影响。

星星头 Slide Star，实际上就是一个外观不同的 Tap：它和 Tap 有着完全一样的判定，甚至在游戏结束时的结算界面，它也被划归为 Tap，出现在 Tap 的统计数据中。一个 Slide Star 可能对应两条或更多的 Slide Track，这被称为同头 Slide。这种 Slide Star 看起来就像是两个星星彼此叠加在了一起，但实际上仍然只有一个 Tap。

随着 Slide Star 向判定线接近，Slide Track 会渐渐浮现，在 Slide Star 应当被击打的时刻**前 100 ms**，Slide Track 完全显示。和 Slide Track 一起出现的，还有引导星星，引导星星提示着玩家何时开始滑动 Slide，以及应当滑多快。引导星星会在 Slide Track 的开头停留一拍的时间，然后再开始移动，引导星星开始移动的时刻，被称为 Slide 的**启动时刻**，启动前等待的一拍则称为**启动拍**。在这一拍时间内，可以看到引导星星在 Slide Track 的起点处逐渐浮现，其在一拍结束时完全显示并开始移动。

> 一拍具体是多久取决于乐曲自身的 BPM，也即“每分钟节拍数”，例如 BPM 150 的乐曲中，引导星星会在 Slide Track 的开头停留 60 / 150 = 0.4 秒再开始移动。

Slide Track 完全显示时（Slide Star 应当被击打的时刻前 100 ms），就可以接受划动了，并不需要等待引导星星浮现。你甚至可以在引导星星还没开始移动的时候，就直接完成整条 Slide Track。实际上，你完全不需要跟随引导星星来滑动 Slide。Maimai 只检查 Slide Track 何时被全部完成。因此，你只需要在引导星星抵达终点的时刻划完整条 Slide Track 即可。

> 其实 Slide Track 完全显示的时机只比 Slide Star 到达判定线提早了 50 ms，但是 Maimai DX 框体本身具有 50 ms 的输入延迟，所以 Slide Star 到达判定线前 100 ms 时触碰判定区，已经可以让 Slide 接受到判定了。

Slide 中有一种具有特殊的形状，被称为 Wifi，如下图所示，它具有三个独立的引导星星，需要双手张大手一起划动完成。

![1w5.png](https://raw.githubusercontent.com/Minepig/MaiMuriDX/master/docs/images/1w5.png)

#### Note 的修饰

Maimai 中有两种修饰 Note 的方式：Ex 和 Break，两者互相独立。所有 Tap（含 Slide Star）和Hold 都可以添加 Ex 修饰，所有 Tap、Hold、Slide Track 也都可以添加 Break 修饰，Ex 和 Break 也可以同时存在，如下图：

![note_modifier.png](https://raw.githubusercontent.com/Minepig/MaiMuriDX/master/docs/images/note_modifier.png)

添加了 Break 修饰后的 Note 会变成红色，打击时会有特殊的音效，并且拥有不同的计分方式；添加了 Ex 修饰后的 Note 会获得一层发光特效，打击时会有特殊的音效，且会把所有不是 Miss 的判定结果提升到 Critical Perfect。

Touch 与 TouchHold 的烟花特效其实也属于一种修饰，但是没有任何判定和计分的功能，仅有特效和音效，因此一般不归入 Note 的修饰中。

### 帧、正解时刻与判定区间

我们知道，Note 是贴合音乐节拍点而放置的，每一个 Note 都有一个应当被正确击打的时刻，这个时刻被称为 Note 的正解时刻。无论玩家是否击打了 Note，Maimai 都会在一个 Note 的正解时刻播放一个打击的音效，这个音效被称为正解音。 

先前提到，Maimai 对判定区和外键的监控是以帧为单位的，且固定每秒 60 帧。然而乐曲的 BPM 往往不会是 3600 的因数，因而 Note 的正解时刻几乎不可能正好对准 Maimai 的监控频率，因此 Maimai 会计算 Note 被实际击打的时刻（对齐到帧）与正解时刻（没有对齐到帧）的时间差，然后与一个预设好的区间作对比，如果时间差落在了某一个判定结果的容许区间内，就把这个判定结果给到当前的 Note，这个区间就是所谓的判定区间。

通常，判定区间的长度都是 16.6667 ms 的整倍数，这恰好是每秒 60 帧下，一帧的时长，因此我们通常也会用帧作为单位来描述判定区间的长度。但是需要注意，这不代表 Maimai 计算判定时是以帧作为单位的，正解时刻并不对齐到帧，因而判定区间边界也不会对齐到帧。**一切的计算实际上都是基于毫秒的**，当某个判定区在某一帧发生了按下事件时，Maimai 会获取当前的具体时刻，以乐曲开始播放为零点，以毫秒为单位，然后用这个时刻与 Note 的正解时刻相减得到毫秒为单位的时间差。这意味着，即使 Maimai 游戏发生了掉帧，即无法满足每秒 60 帧的帧率，判定计算也不会受影响，不会导致正解时刻的错位或是判定区间的长度变化，只不过对判定区和外键的监控频率会因为掉帧而下降。

为了数字简单起见，接下来的判定区间都会以帧作为时间单位，它们具体以毫秒为单位的时间可以简单通过乘以 16.6667 得到。

### Tap 的判定

对于 Tap 而言，一共有 5 种基础的判定，即 Critical Perfect、Perfect、Great、Good、Miss。其中，Perfect 细分为 2 种子判定，Great 细分为 3 种子判定。对于这些判定，除了 Critical Perfect、Miss 以外的所有判定都有 Fast 和 Late 两种情况。

因此，完整的判定共有 14 种。它们对应的判定区间相对于正解时刻对称，如下表所示，注意表中所有“A ~ B”的区间都包含更远离 0 的那一侧端点（正中的 -1 ~ +1 两端都包含）：

|         判定结果         | 区间范围 (帧) | 区间长度 (帧) |
| :------------------: | :------: | :------: |
|    Fast **Good**     | -9 ~ -6  |    3     |
|  Fast **Great** 3rd  | -6 ~ -5  |    1     |
|  Fast **Great** 2nd  | -5 ~ -4  |    1     |
|  Fast **Great** 1st  | -4 ~ -3  |    1     |
| Fast **Perfect** 2nd | -3 ~ -2  |    1     |
| Fast **Perfect** 1st | -2 ~ -1  |    1     |
| **Critical Perfect** | -1 ~ +1  |    2     |
| Late **Perfect** 1st | +1 ~ +2  |    1     |
| Late **Perfect** 2nd | +2 ~ +3  |    1     |
|  Late **Great** 1st  | +3 ~ +4  |    1     |
|  Late **Great** 2nd  | +4 ~ +5  |    1     |
|  Late **Great** 3rd  | +5 ~ +6  |    1     |
|    Late **Good**     | +6 ~ +9  |    3     |
| **Miss** (Too Late)  |  +9 以后   |    -     |

如果在一张图中绘制出所有的判定区，可以得到下图：

![tap_judge.png](https://raw.githubusercontent.com/Minepig/MaiMuriDX/master/docs/images/tap_judge.png)

如果 Tap 是被保护的 Ex-Tap，那么上述判定区间中所有不是 Miss 的部分都将提升为 Critical Perfect，也就是说整个 -9 ~ +9 的范围都将是 Critical Perfect。

### A、B 判定调整

Maimai 有 A、B 两种判定调整，通常俗称为 A 判、B 判。在 Maimai 的官方文本解释中，A 判调整 Note 到达判定线的时间，适合靠听节奏来游玩的玩家；B 判直接调整判定的时机，适合靠目押来游玩的玩家。因此 A 判也被称作“音押判定”，B 判也被称作“目押判定”。

A 判实际上调节的是谱面相对于乐曲的延后时间，单位是帧，A 判 +0.5 表示所有与 Note 相关的时刻都会相对于原本晚 0.5 帧。具体举例，这代表 Tap 到达判定线的时刻、Touch 快门闭合的时刻等都会比乐曲节拍点晚 0.5 帧。或者应该说，保持其他时机不变的情况下，乐曲的播放比原先提前了 0.5 帧，此时 Tap 到达判定线的时刻依然是正解时刻，但不再与乐曲节拍点符合。由于正解音永远在 Tap 到达判定线或 Touch 闭合的时刻播放，所以正解音也会和乐曲节奏错位。

B 判调节的则是判定区间相对于谱面的延后时间，单位也是帧，B 判 +0.5 表示所有 Note 的正解时刻和判定区间全部相对于原本向 Late 方向移动 0.5 帧。此时 Tap 到达判定线的时刻与乐曲节拍点符合，正解音也正好对上乐曲节奏，但是这三者都不再对准判定区间中央的正解时间了，因此 B 判常用于补偿输入延迟。

关于 A 判与 B 判的具体效果可以参考下图，其中向右为 Late 的方向：

![offset_setting.png](https://raw.githubusercontent.com/Minepig/MaiMuriDX/master/docs/images/offset_setting.png)

可以推断出，假如把 A 判和 B 判调节为相反数，可以让正解时刻和乐曲节拍点符合，但是 Tap 到达判定线的时刻会提前或者延后（一些移动端音游称之为图像偏移量）。不过，由于正解音永远是跟着谱面走的，这样调仍然会让正解音和乐曲错位。

> 可能是冷知识：DX 框体实际上内部自带了 +3.0 的 B 判，这可能是为了补偿硬件和软件的输入延迟。如果有条件的话可以通过内录全 Miss 的谱面确认来证实这一点 —— Tap 实际会在到达判定线之后第 12 帧才 Miss，而不是第 9 帧。

> 这或许是 DX 框体刚刚发行时，许多习惯了旧框的玩家在 DX 框体上总是会打出 Fast 的原因，甚至把 A 判或者 B 判调成 -2.0 也无法完全弥补过来。

### Hold 的判定

Hold 的判定由两部分组成：头部判定和按压判定。Hold 的头部判定完全等同于一个 Tap，具有 18 帧的宽度，以及完全相同的判定区间。当 Hold 的头部被击打后（或是没有及时击打导致 Miss 以后），这个判定就会被记录下来，直到 Hold 结束时参与最终判定的结算。与 Tap 类似，如果 Hold 是被保护的 Ex-Hold，那么头部判定也如同 Ex-Tap 一样，只有 Critical Perfect 和 Miss 两种判定。

在 Hold 的持续过程中，会不断统计 Hold 被按压的时长。按压和头部判定无关，即便头部判定为 Miss，玩家仍然可以按住 Hold。不过，需要注意的是：Hold 开头的 6 帧与结尾的 12 帧不会检查 Hold 是否被按压，也不会统计按压时长。 

> 准确说来，Hold 统计的是玩家松开的时长，而且在玩家松开时 Hold 并不会立刻开始记录松开时长，而是会等待 3 帧，如果玩家连续 3 帧都没有按压 Hold，Hold 就会进入松开的状态，开始统计松开时长，而且先前等待的 3 帧也会一并计入松开时长。不过，如果松开的时长不足 3 帧，Hold 会保持被按下的状态。

当 Hold 结束后，会根据头部判定和按压时长百分比，综合计算出最终的判定结果。按压时长百分比就是统计的按压时长与进行检查的总时长（也即 Hold 总持续时长扣除首尾忽略的 18 帧）的比值。如果 Hold 的总持续时长不足 18 帧，那么由于完全没有统计按压时长，Hold 的最终判定将与头部判定相同（俗称短 Hold、假 Hold）；其他情况下，Hold 的最终判定由下表决定：

![hold_judge.png](https://raw.githubusercontent.com/Minepig/MaiMuriDX/master/docs/images/hold_judge.png)

需要特别注意的是，Ex 保护**只会保护头部判定**，即使是 Ex-Hold，在击打头部并获得 Critical Perfect以后如果完全不按压，最终判定依然会降低到 Late Good，不会因为保护而维持 Critical Perfect。

### Touch 的判定

Touch 的判定区间比较特殊，它没有 Fast 判定，只有 Critical Perfect 以及其他 Late 判定。Touch 的判定区间如下表：

|         判定结果         |  区间范围 (帧)   | 区间长度 (帧) |
| :------------------: | :---------: | :------: |
| **Critical Perfect** |   -9 ~ +9   |    18    |
| Late **Perfect** 1st | +9 ~ +10.5  |   1.5    |
| Late **Perfect** 2nd | +10.5 ~ +12 |   1.5    |
|  Late **Great** 1st  |  +12 ~ +13  |    1     |
|  Late **Great** 2nd  |  +13 ~ +14  |    1     |
|  Late **Great** 3rd  |  +14 ~ +15  |    1     |
|    Late **Good**     |  +15 ~ +18  |    3     |
| **Miss** (Too Late)  |   +18 以后    |    -     |

换言之，即便在 Touch 出现前就不断尝试触碰这个 Touch，也不会获得不好的判定。因此，Touch 可以通过“擦玻璃”的方式来“糊”。

Touch 的判定还有一套容错机制，被称为 TouchGroup 机制。在同一时刻出现（即被标注为黄色的“Each Touch”），且彼此相邻的 Touch，会相互链接，形成一个 TouchGroup。

判断两个 Touch 是否相邻基本等同于判断它们所属的判定区在图像上是否有邻边，如下图所示，若两个判定区有线段直接连接，表示两个判定区相邻：

![judge_areas2.png](https://raw.githubusercontent.com/Minepig/MaiMuriDX/master/docs/images/judge_areas2.png)

注意相同键位的 A 区和 B 区是相邻的，尽管图像上看两者似乎空开了一点。

当 TouchGroup 中超过半数（≥ 51%）的 Touch 获得判定后，剩余的 Touch 也会立即获得与最后一个判定的 Touch 相同的判定。举几个例子：

1. B1/E2 形成了一个大小为 2 的 TouchGroup。当 B1 获得判定后，已判定的占比为 50% < 51%，因此 E2 仍然等待被判定。换言之，大小为 2 的 TouchGroup 不会享受该机制带来的好处。
2. B1/E2/B2 形成了一个大小为 3 的 TouchGroup。当 B1 和 E2 都获得 Critical Perfect 判定后，已判定的占比为 66.67% ≥ 51%，因此 B2 也立即获得 Critical Perfect 判定。
3. C/B7/B6/E7/B2/B3/E3 形成了一个大小为 7 的 TouchGroup。当 B7/B6/E7 获得 Critical Perfect 判定后，已判定占比 < 51%。随后，C 获得了 Late Good 判定，此时已判定占比 ≥ 51%，因此B2/B3/E3 也立即获得 Late Good 判定。

### TouchHold 的判定

TouchHold 的判定就如同 Touch 和 Hold 的综合体，它像 Hold 一样具有头部判定和按压判定。TouchHold 的头部判定和 Touch 完全一致，没有 Fast，Critical Perfect 的区间也有 18 帧宽度。唯一可能称得上区别的，是 TouchHold 不会参与形成 TouchGroup，例如下图就是两组 TouchGroup 与单独一个 TouchHold 的配置：

![Oshama Scramble! [DX] Expert (3).png](https://raw.githubusercontent.com/Minepig/MaiMuriDX/master/docs/images/Oshama%20Scramble!%20[DX]%20Expert%20(3).png)

TouchHold 的按压判定则与 Hold 一致，不过由于头部判定宽松，开头忽略的时长由 6 帧延长到了 15 帧，结尾依然是 12 帧，因此如果 TouchHold 的总持续时长不足 27 帧，就会因为完全不检查按压，而导致最终判定与头部判定相同（称为短 TouchHold 或假 TouchHold）。持续时长超过 27 帧的情况下，最终判定根据头部判定和按压时长百分比计算，与 Hold 完全相同。

### Slide 的判定

一条 Slide 分为 Slide Star 和 Slide Track，Slide Star 本身等价于一个 Tap，适用于上文 Tap 判定的一切内容，而后续的 Slide Track 判定才是 Maimai 中最复杂的内容。

#### 判定段与判定队列

一条 Slide 会经过若干个内屏上的判定区，这些判定区将 Slide 分割成了一段一段的“判定段”，每个判定段都对应于内屏上 1~2 个判定区。**想要完成一条 Slide，原则上应该依次触碰每一个判定段的至少一个判定区**。

在内屏全部 33 个判定区中，只有 A、B、C 区共 17 个判定区参与 Slide 的判定，而 **D 区和 E 区是完全不参与 Slide 判定的**，因此 Slide 分割判定段时也会对 D 区和 E 区视而不见（例外是 Wifi，下面会提到）。

将判定段按顺序排列，即得到 Slide 的判定队列。以 8pp5 为例，如下左图所示，可以写出其判定队列为：A8, B8, C, B3, A2, A1, B8, B7/C, B5/B6, A5，总共 10 个判定段。尽管 8pp5 的 Slide Track 接触到了 E3、D2、E1、E6，由于 D 区和 E 区不参与 Slide 的判定，故它们并没有出现在判定队列中。

![8pp5.png](https://raw.githubusercontent.com/Minepig/MaiMuriDX/master/docs/images/8pp5.png) ![1-3.png](https://raw.githubusercontent.com/Minepig/MaiMuriDX/master/docs/images/1-3.png)

判定队列中 B7/C 与 B5/B6 意味着该判定段包含两个判定区，任选其中一个判定区触碰即可完成该判定段，这被称为 OR 判定段。出现 OR 判定段的情况一般是由于 Slide Track 经过了某两个判定区的分界线，最常见的情况是三格长的短直线，例如上右图中 1-3 的判定队列是：A1, A2/B2, A3。同样的，D2、E2、D3、E3 并不会出现在队列中。

Wifi 可以看作三条同头的直线 Slide 的复合，但判定更为宽松化。因此 Wifi 具有三个独立的判定队列，它们之间没有关联，可以同时处理或者先后分开处理。但无论怎么处理，只有这三个判定队列各自都被完成以后，整条 Wifi 才算作完成。

以 1w5 为例，如下图所示，其可以视为 1-4、1-5、1-6 的组合，但 Wifi 的判定宽松化允许 1-4 与 1-6 的部分最后一个判定段使用 D 区解决，而 1-5 的部分则将最后两个判定段拼合为了一段。因此 1w5 的三个判定队列分别是：A1, B2, B3, A4/D5；A1, B1, C, B5/A5；A1, B8, B7, A6/D6。Wifi 是唯一一种 D 区参与到 Slide 判定中的情况。

![1w5.png](https://raw.githubusercontent.com/Minepig/MaiMuriDX/master/docs/images/1w5.png)

对于 Festival 代加入的连锁 Slide，其只拥有单一的判定队列，且判定队列为各部分拼合的结果，例如 1-6 的判定队列是 A1, B8, B7, A6，6-4 的判定队列是 A6, A5/B5, A4，那么两者组成连锁 Slide 1-6-4，判定队列就是：A1, B8, B7, A6, A5/B5, A4。

#### 判定段检查与跳区规则

在 Slide 的整个判定队列中，除了最后一段只需要按下不需要松开，其他每一段都需要经历**从按下到松开**的“下降沿”过程才会被解决。当一个判定段被解决以后，它会从判定队列中被移除。**判定队列清空的时刻代表 Slide 完成的时刻**，此时 Slide 会进行判定计算，将 Slide 完成时刻与**引导星星的中心进入最后一个判定区的时刻**作比较，并给出判定结果。

具体而言，当一条 Slide Track **已经可以接受判定**了以后（也即 Slide Track 完成了渐入完全显示的时刻，或者说 Slide Star 应当被击打的时刻**前 100 ms**，或者说 6 帧），Maimai 就会在每一帧中都检查并更新判定队列的状态。

Maimai 会先检查 Slide 判定队列中剩余部分的首个判定段。如果这个判定段中的某一个判定区处于 ON 状态，那么 Slide 的这一判定段就会进入一种“解决了一半”的状态。

如果这个判定段在之前的检查中已经由于上述原因处于“解决了一半”的状态，则检查已经处于 ON 状态的那个判定区是否被松开。如果被松开，或者说这个判定区变成了 OFF 状态，那么首个判定段就被解决了，Maimai 会把它从判定队列里移除。

换言之，首个判定段中的判定区必须要**先按下再松开**，这个判定段才会被解决。除非判定队列中只剩下了**最后一个判定段**，此时的首个判定段就是初始队列中的最后一段，这一段**不要求松开**，只要对应的判定区处于 ON 状态，这一个判定段就会立刻被完成，从判定队列中移除。此时判定队列恰好清空，Maimai 会计算 Slide 的判定结果。

此外，应该是出于一些容错的考虑，Maimai 还会检查 Slide 判定队列剩余部分的第二个判定段，如果此时第二个判定段对应的判定区处于 ON 状态，那么**无论首个判定段现在处于什么状态**，都会立刻被解决并移出队列，这被称作“跳区”规则。

以上的检查会在一帧中**反复执行多次**，直到判定队列不再发生变化为止。

还是以 8pp5 为例，判定队列为：A8, B8, C, B3, A2, A1, B8, B7/C, B5/B6, A5。

![8pp5.png](https://raw.githubusercontent.com/Minepig/MaiMuriDX/master/docs/images/8pp5.png)

由于存在跳区规则，我们实际上可以依次“点按”（按下再松开）这五个判定区就可以完成这整条 Slide：B8，B3，A1，C，A5，其中每按一个判定区都会跳过某一个判定段，因此不需要触碰所有十个判定段。

再想象一个情景，假如你在 8pp5 的 Slide Track 还在渐入的时候（还未接受判定），按住了所有十个判定段（什么？你问怎么按？或许你可以肘击滴蜡熊），那么当 Slide Track 渐入完成开始接受判定的那一帧，会发生什么事情？

很显然，整条 Slide 会立刻被全部完成，具体细节如下：由于第二个判定段 B8 已经处于 ON 状态，A8 被跳过，C 成为了第二个判定段；然后由于 C 处于 ON 状态，尽管 B8 还未松开但依然会被跳过，B3 又成为了第二个判定段；之后以此类推直到判定队列只剩下了 B5/B6 和 A5 两段，此时 A5 处于 ON 状态，跳过了 B5/B6，只剩 A5，最后由于 A5 不需要松手，而它又正好处于 ON 状态，A5 被立刻解决，判定队列清空，于是你喜提一条绿色的 Slide。

想象第三个情景，假如你迅速的把 8pp5 划至只剩 B7/C, B5/B6, A5 三个判定段，此时你的左手按住 A5，右手按住 C，且保证不触碰到 B5 和 B6，会怎么样？

第一次检查，由于 C 处于 ON 状态，首个判定段 B7/C 进入“解决了一半”的状态。然后第二次检查，发现不产生任何变化（因为 A5 是此时的第三个判定段，不会被检查），于是检查结束。

假如接下来你把右手松开了，那么在松手的这一帧中，第一次检查发现 C 变为了 OFF，B7/C 被解决移出队列。然后第二次检查，首个判定段已经变成了 B5/B6，A5 成为第二个判定段且恰好处于 ON 状态，于是跳过 B5/B6，并且由于 A5 不需要松手，A5 被直接解决。于是判定队列清空，Slide 计算并显示判定结果。

以上的过程，仿佛是因为我们松开了 C，游戏才开始判定，所以常常被玩家称作“松手判定”。但实际上，我们按下 C 时，B7/C 并未被完全解决，自然也就不会去检查 A5。而松开 C 后，A5 变成了第二个判定段，就会被检查了，因此触发了跳区。这样的过程发生在同一帧内，因此看起来似乎是游戏有着“松手判定”的规则。但是实际上**只是因为判定区状态的转变引起了多米诺效应，达成了这样的结果，并没有所谓的“松手判定”的特殊规则**。

再举第四个情景，假设 8pp5 之前连接了一条 4-8 的直线 Slide，其结束时刻正好与 8pp5 的启动时刻一致，组成了俗称“一笔画”的配置。当你外键击打 8 号键的 Slide Star 并划完了 4-8 以后，发现 8pp5 已经消除到 B3 区了，可是理论上来说跳区只会跳一个区，为什么现在的结果像是跳过了 A8 和 B8 两个区直接判定了 C 区？

原因其实很简单：手是有面积的，划 4-8 的过程中，在某一帧 C 和 B8 同时都处于 ON 状态，于是就会连续触发两次跳区使首个判定段变为 C，然后在手离开 C 区以后，解决掉 C，导致 8pp5 已经消除到了 B3。

#### 跳区保护

在几种特殊情况中，对第二个判定段的检查会被禁用：

1. 判定队列总长度 ≤ 3 的标准 Slide 或连锁 Slide，其倒数第二个判定段不可以跳过，如 8<7 不可跳 A8、1>3 不可跳 A2、6-4 不可跳 A5/B5；7>8>1 同 7>1，不可跳 A8；
2. 单独一条标准的转折 Slide（即大 V 形 Slide）中长度为 3 的部分，第二个判定段不可跳过，例如 1V35 的第二段 A2/B2、第四段 A4/B4 均不可跳过，5V73 只有第二段 A6/B6 不可跳过。

这些 Slide 的形状以及不可跳过的判定段如下图所示（使用不同颜色区分）：

![slide_jump_area.png](https://raw.githubusercontent.com/Minepig/MaiMuriDX/master/docs/images/slide_jump_area.png) ![slide_jump_area2.png](https://raw.githubusercontent.com/Minepig/MaiMuriDX/master/docs/images/slide_jump_area2.png)

特别的，对于连锁 Slide 1-3-5，尽管其形状和 1V35 相同，判定队列也完全相同，但由于它不是转折 Slide，故不适用于上述第二条规则，然后在判定第一条规则时，由于判定队列总长度为 5 > 3，于是不存在不可跳过的判定段。而 1V35 会由于上述第二条规则拥有两个不可跳过的判定段。

此外，第二条规则要求转折 Slide 必须是单独的一条。如果转折 Slide 参与形成连锁 Slide，也会失去上述第二条的特权，例如 1-3V57 和 1-3-5-7 一样，每一个判定段都可以跳过，**不会**因为 3V57 的存在导致 A4/B4 和 A6/B6 不允许跳区。

在上述两种跳区被禁用的情况下，如果 Slide 当前的判定队列剩余部分中首个判定段不可以跳过，那么 Maimai 不会在首个判定段还未开始解决时，检查第二个判定区，但是如果首个判定段已经“解决了一半”，那么如果第二个判定段对应的判定区处于 ON 状态，依然可以触发跳区，无需等待首个判定段完全解决。

以 1-3 为例，判定队列是 A1, A2/B2, A3，其中 A2/B2 不可跳过，那么“点按”（按下再松开）A1 之后，直接按 A3 就不会有任何变化，因为 A2/B2 还没有开始解决，跳区被禁用。但是如果在按住 A3 的情况下去触碰 A2，Slide 就会立刻被完成。这是由于 A2 变为 ON 的那一帧，A2/B2 进入“解决了一半”的状态，允许跳区，而 A3 已经处于 ON 状态，于是就触发跳区跳过了 A2/B2。

> 如果一条连锁 Slide 由转折 Slide 起始，则会出现一些很迷惑的现象，这疑似是 Festival 加入连锁 Slide 时忘记修改相关逻辑产生的 Bug。

> 具体而言，此时 Maimai 会根据 Slide 起始点和终止点来判断 Slide 的形状，1V37-5 由转折 Slide 起始，其起始点是 1 号键，终止点是 5 号键，因而会被当作 1V35 来应用禁止跳区规则，1V35 的第二个区和第四个区不可以跳过，因而 1V37-5 的第二个区和第四个区也不可以跳过，也即 1-3 部分的 A2/B2 和 3-7 部分的 B2。而 1V35-7 则会被当作 1V37，从而只有第二个区 A2/B2 不可以跳过。至于 1V37-1，会被当作 1V31，但由于不存在 1V31 这种 Slide，于是会 fallback 到上述第一条规则，而显然 1V37-1 的判定队列长度 > 3，因而每一个判定段都可以跳过。另外，上文提到的 1-3V57 由 1-3 起始，并不是转折 Slide，因此不在讨论范围内。

> 不过由于上述迷惑现象看起来很像是 Bug，所以 MaiMuriDX 在检测时选择一刀切把所有长度 > 3 的连锁 Slide 定为全部允许跳区，相当于是把跳区规则稍微宽松化了一点（应该不会有人都写连锁 Slide 了还在大 V 吧）。

#### Slide 尾判

前文已经提到，**判定队列清空的时刻代表 Slide 完成的时刻**，此时 Slide 会进行判定计算，这个判定计算的过程就是 Slide 尾判。

Slide 尾判的正解时刻是**引导星星的中心进入 Slide 最后一个判定区的时刻**。

> 实际上，由于这个正解时刻是根据 Slide 各个判定段的长度与 Slide 总持续时间综合计算出来的，而 Slide 各个判定段的长度数据并不准确，或者应该说误差有点过于大了。因此正解时刻并不精确等于引导星星的中心进入最后一个判定区的时刻，而是有一定的出入，通常正解时刻位于引导星星的中心运动到末尾 A 区的边界附近 10 px 范围内的某个点的时刻，由于 Slide 判定宽松，这个误差通常属于可以接受的范围。

> 外圈圆弧形的 Slide 正解时刻的误差较大，其正解时刻实际上位于引导星星运动到末尾 A 区前的 D 区中心附近。这可能是为了模仿旧框的 Slide 尾判手感。

Slide 尾判的判定区间如下表所示，其中 T 表示引导星星在最后一个判定区停留的时长，或者说 T 表示 Slide 尾判的正解时刻到 Slide 结束时刻的时间差（注意 墨滢-moying 的专栏对这部分的介绍有许多错误，请以此处的讲解为准）：

|           判定结果           |     区间范围 (帧)      | 区间时长 (帧) |
| :----------------------: | :---------------: | :------: |
| Fast **Good** (Too Fast) |      -36 之前       |    -     |
|      Fast **Good**       |     -36 ~ -29     |    7     |
|    Fast **Great** 3rd    |     -29 ~ -25     |    4     |
|    Fast **Great** 2nd    |     -25 ~ -21     |    4     |
|    Fast **Great** 1st    |     -21 ~ -17     |    4     |
|   **Critical Perfect**   |     -17 ~ -14     |    3     |
|   **Critical Perfect**   | -14-T/4 ~ +14+T/4 |  28+T/2  |
|    Late **Great** 2nd    |     +14 ~ +19     |    5     |
|    Late **Great** 3rd    |     +19 ~ +23     |    4     |
|      Late **Good**       |     +23 ~ +36     |    13    |
| Late **Good** (Too Late) |    +36 ~ T+33     |   T-3    |
|   **Miss** (Too Late)    |      T+33 以后      |    -     |

这张表乍一看十分的令人迷惑，不仅不对称，而且还有两个 Critical Perfect 区间，接下来会对每一个细节进行解释。

首先是位于整个判定区间正中央的 Critical Perfect 区间，其区间范围是受引导星星在最后一个判定区停留的时长而变化的，引导星星在最后一个区停留越久，中央 Critical Perfect 的区间就越大，这被称为区间扩展机制。

具体而言，中央 Critical Perfect 的判定区间会向两侧各扩展 (T/4) 的时长，其中 T 是引导星星在最后一个判定区停留的时长。扩大后的区间会逐渐覆盖掉两侧的其它区间，但是不会覆盖 ±36 帧以外的 Too Fast 和 Too Late 区间。

此外，Slide 判定 Miss 的时机是以 Slide 完全结束的时刻为基准的，而不是以上述正解时刻，这就导致 Miss 的判定区间后移了等同于 T 的时间，从原先 +33 处变成了 T+33。

举例来说，假如某 Slide 的引导星星将会在最后一个判定区停留 50 帧，那么中央区间将向两侧各扩展 12.5 帧。那么，这条 Slide 的判定区间将会变为这样：

|           判定结果           |   区间范围 (帧)    | 区间时长 (帧) |
| :----------------------: | :-----------: | :------: |
| Fast **Good** (Too Fast) |    -36 之前     |    -     |
|      Fast **Good**       |   -36 ~ -29   |    7     |
|    Fast **Great** 3rd    |  -29 ~ -26.5  |   2.5    |
|   **Critical Perfect**   | -26.5 ~ +26.5 |    53    |
|      Late **Good**       |  +26.5 ~ +36  |   9.5    |
| Late **Good** (Too Late) |   +36 ~ +83   |    47    |
|   **Miss** (Too Late)    |    +83 以后     |    -     |

最极端的情况，如果某 Slide 的引导星星在最后一个判定区停留的时长超过 88 帧（1.467 s）时，Slide 将只剩下 Fast Good (Too Fast)、Critical Perfect、Late Good (Too Late) 和 Miss (Too Late) 这四种判定。典型例子是白南十字的超慢速 Slide `(128.6)3v1[1:11]/7v5[1:11]`，Slide 总长为 20.53 s，在最后一个区停留 3.344 s，即 200.6 帧，于是这两条 Slide 的判定区间就变成了这样：

|           判定结果           |   区间范围 (帧)   | 区间时长 (帧) |
| :----------------------: | :----------: | :------: |
| Fast **Good** (Too Fast) |    -36 之前    |    -     |
|   **Critical Perfect**   |  -36 ~ +36   |    72    |
| Late **Good** (Too Late) | +36 ~ +233.6 |  197.6   |
|   **Miss** (Too Late)    |  +233.6 以后   |    -     |

再考虑另一个极端，如果某 Slide 的引导星星在最后一个判定区停留的时长甚至不足 12 帧，那么中央 Critical Perfect 区间扩展以后依然无法完全覆盖 -17 ~ -14 区间的 Critical Perfect，那么这一段额外的 Critical Perfect 就会发挥作用，相当于再次扩展了中央 Critical Perfect 的区间，但是只往 Fast 方向扩展。以紫提尾杀前的 `(215)4z8[8:1]/5s1[8:1]` 为例，Slide 总长只有 0.1395 s 即 8.372 帧，在最后一个区只停留 0.88 帧，于是两条 Slide 的判定区间就变成了这样：

|           判定结果           |   区间范围 (帧)   | 区间时长 (帧) |
| :----------------------: | :----------: | :------: |
| Fast **Good** (Too Fast) |    -36 之前    |    -     |
|      Fast **Good**       |  -36 ~ -29   |    7     |
|    Fast **Great** 3rd    |  -29 ~ -25   |    4     |
|    Fast **Great** 2nd    |  -25 ~ -21   |    4     |
|    Fast **Great** 1st    |  -21 ~ -17   |    4     |
|   **Critical Perfect**   | -17 ~ +14.22 |  31.22   |
|    Late **Great** 2nd    | +14.22 ~ +19 |   4.78   |
|    Late **Great** 3rd    |  +19 ~ +23   |    4     |
|      Late **Good**       | +23 ~ +33.88 |  10.88   |
|   **Miss** (Too Late)    |  +33.88 以后   |    -     |

可以注意到，在 Slide 速度很快的情况下，Critical Perfect 的区间不再对称（因为 -17 ~ -14 区间的存在），而且 Late Good 的区间也会被少量压缩。

下图中展示了当 Slide 的引导星星在最后一个区停留 8 帧和 28 帧的情况下，Slide 的判定区间：

![slide_judge.png](https://raw.githubusercontent.com/Minepig/MaiMuriDX/master/docs/images/slide_judge.png)

值得一提的是，如果 Slide 获得了 Miss 的判定但此时**判定队列中只剩最后一个判定段**，那么 Miss 会被提升为 Late Good，这就是俗称的“留尾判绿”。留尾必须是留最后一个判定段才能判为 Good，如果留了至少两个判定段，判定结果依然是 Miss。

#### Slide 的事件队列理论

事件队列理论是 インクInku墨 于 2021 年发布的一个关于 Slide 判定的视频（BV1Tq4y1f73d）中提出的理论（原文是“判定队列理论”，为避免与上文所述判定队列混淆，故意更改了名字）。该理论是基于上机实验结果逆向推定的理论，核心思想与上文有所出入，但最终的结果是一致的。在此将该理论一并介绍，希望可以帮助读者理解。

以 1-5 为例，其判定队列是 A1, B1, C, B5, A5，如图所示。下面讲解事件队列理论是如何处理这根 Slide 的判定的：

![1-5.png](https://raw.githubusercontent.com/Minepig/MaiMuriDX/master/docs/images/1-5.png)

事件队列理论将判定队列中的每个判定段进一步拆分为事件，得到如下事件队列：

```
A1[ON], A1[UP], B1[ON], B1[UP], C[ON], C[UP], B5[ON], B5[UP], A5[ON]
```

队列中的 ON 代表“判定区处于 ON 状态”，与 OFF 相对，而 UP 则代表“判定区经历从 ON 变为 OFF 的松开事件”，与 DOWN 相对。从这个事件队列中就可以观察到，最后一个判定段 A5 无需松开。

> 原视频中使用了 OFF 来代替 UP，但为了防止混淆，此处沿用先前的术语定义：ON/OFF 代表按下/松开**状态**，而 DOWN/UP 代表按下/松开**事件**

事件队列理论对于跳区规则的诠释是：任一时刻 Slide 只会尝试检查队列中前三个事件是否满足，如果有一个事件满足，会将该事件以及其前面的所有事件一起移出队列。

仍然以 1-5 为例，如果同时按住 B1 和 B5 并且不触碰 C 区，Slide 检查前三个事件时发现第三个事件 `B1[ON]` 已经满足，于是会将 `A1[ON], A1[UP], B1[ON]` 全部移出队列，此时队列变成了：

```
B1[UP], C[ON], C[UP], B5[ON], B5[UP], A5[ON]
```

由于 B1 只是被按住没有松开，`B1[UP]` 并没有满足，因此前三个事件中也就不包含 `B5[ON]`，因此此时按住 B5 区是不会有任何反应的。如果松开 B1，那么这一帧内 Slide 检查发现 `B1[UP]` 满足，将其移出队列后，`B5[ON]` 进入前三个事件，而此时 B5 区正好被按住，于是事件队列可以再次消除到只剩最后两个事件 `B5[UP], A5[ON]`。

对于禁止跳区的情况，以 1-3 为例，事件队列理论给出的解释是 1-3 的事件队列如下所示：

```
A1[ON], A1[UP], A2/B2[ON], A2/B2[ON], A2/B2[UP], A3[ON]
```

![1-3.png](https://raw.githubusercontent.com/Minepig/MaiMuriDX/master/docs/images/1-3.png)

可见 `A2/B2[ON]` 事件重复了两次，这样在点按了 A1 区以后，事件队列成为：

```
A2/B2[ON], A2/B2[ON], A2/B2[UP], A3[ON]
```

由于重复的 `A2/B2[ON]` 事件的存在，`A3[ON]` 并没有进入前三个事件，因此直接按 A3 并不能跳过 A2/B2 判定段。然而按住 B2 不放手会一次性将两个 `A2/B2[ON]` 一起消耗掉，此时 `A3[ON]` 进入前三个事件，按 A3 就可以跳过 A2/B2 了。

### 计分规则

在游玩了一张谱面后，Maimai 会记录下每一个 Note 得到的判定结果，据此计算出谱面的成绩。谱面成绩一般由两部分组成：达成率和 DX 分。下面介绍这两者分别的计算规则。

|         判定结果         | Tap/Touch | Hold/TouchHold | Slide Track | Break | Break Bonus | DX  |
| :------------------: | :-------: | :------------: | :---------: | :---: | :---------: | :-: |
| **Critical Perfect** |     1     |       2        |      3      |   5   |      1      |  3  |
|   **Perfect** 1st    |     1     |       2        |      3      |   5   |    0.75     |  2  |
|   **Perfect** 2nd    |     1     |       2        |      3      |   5   |     0.5     |  2  |
|    **Great** 1st     |    0.8    |      1.6       |     2.4     |   4   |     0.4     |  1  |
|    **Great** 2nd     |    0.8    |      1.6       |     2.4     |   3   |     0.4     |  1  |
|    **Great** 3rd     |    0.8    |      1.6       |     2.4     |  2.5  |     0.4     |  1  |
|       **Good**       |    0.5    |       1        |     1.5     |   2   |     0.3     |  0  |
|       **Miss**       |     0     |       0        |      0      |   0   |      0      |  0  |

达成率的计算取决于每个 Note 的具体类型以及判定结果，如果一个 Note 有 Break 修饰，那么无论它是 Break-Tap、Break-Hold 还是 Break-Slide，统一按照上表中 Break 列的分数来计分。如果不是 Break，那么根据 Note 的具体类型，查阅对应列的分数进行计分。注意 Slide Star 被视为 Tap，按照 Tap 列的分数进行计分。

在所有 Note 的分数全部统计完成后，将分数求和得到基础分，然后 Maimai 会去计算基础分的理论满分 —— 也即所有 Note 全部按照 Critical Perfect 完成的总分。将两者相除得到的百分比即为达成率的基础分的部分。

达成率还有额外分的部分，这是由所有 Break 类型 Note 产生，对谱面中所有拥有 Break 修饰的 Note，按照 Break Bonus 列计分，求和得到额外分。然后计算额外分总分，这其实就是 Break 修饰 Note 的总数，将两者相除，再除以 100，得到一个介于 0% ~ 1% 之间的数据，这就是达成率中额外分部分。

最终的达成率百分比是基础分和额外分的和，因此达成率的理论满分是 100% + 1% = 101%。达到该理论值的要求是所有 Break 修饰的 Note 都获得 Critical Perfect，而所有非 Break 的 Note 都至少获得 Perfect 2nd 及以上的判定。如果达成了这个条件，称为 All Perfect +。

DX 分是独立于达成率的另一套成绩系统，它不关心 Note 的类型，只关心最终的判定，将所有 Note 按照 DX 列的分数计分，求和后即得到 DX 分。DX 分并不以百分比形式展示，DX 分的理论满分是谱面物量的 3 倍（物量，即谱面中 Note 的总数，注意 Slide Star 和 Slide Track 是记作两个不同的 Note 的）。很显然 DX 分达到满分的要求是所有 Note 都获得 Critical Perfect，比达成率满分更困难。

> 在旧框中达成率没有额外分的部分，取而代之的是 Break 列的前三行要依次更改为 5.2，5.1，5。在计算基础分总分时，Break 会按照 5 分计算（相当于所有 Note 都按照 Perfect 2nd 计分），因此最后计算出来的达成率百分比依然可以超出 100%，但满分的具体数值需要由谱面物量和 Break 数量综合计算得到。在谱面中所有 Note 都为 Break 时，达成率满分最高，为 104%。

> 实际上在 Maimai 计算分数时，上表中基础分的部分每一分实际上是 500 分，额外分的部分每一分实际上是 100 分，但由于最后的达成率是比值，我在这里做了归一化。如果用 500 分作为单位，那么上面所说旧框的 Break 前三行分数依次应该为 2600，2550，2500。因此玩家会把 Break 的 Perfect 1st 判定称为 50 落，Perfect 2nd 判定称为 100 落。
